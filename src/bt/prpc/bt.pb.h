// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bt.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bt_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_bt_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_bt_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_bt_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_bt_2eproto;
namespace prpc {
class BtFile;
struct BtFileDefaultTypeInternal;
extern BtFileDefaultTypeInternal _BtFile_default_instance_;
class BtStatusRequest;
struct BtStatusRequestDefaultTypeInternal;
extern BtStatusRequestDefaultTypeInternal _BtStatusRequest_default_instance_;
class BtStatusRespone;
struct BtStatusResponeDefaultTypeInternal;
extern BtStatusResponeDefaultTypeInternal _BtStatusRespone_default_instance_;
class DownloadRequest;
struct DownloadRequestDefaultTypeInternal;
extern DownloadRequestDefaultTypeInternal _DownloadRequest_default_instance_;
class DownloadRespone;
struct DownloadResponeDefaultTypeInternal;
extern DownloadResponeDefaultTypeInternal _DownloadRespone_default_instance_;
class FileCompletedReq;
struct FileCompletedReqDefaultTypeInternal;
extern FileCompletedReqDefaultTypeInternal _FileCompletedReq_default_instance_;
class FileCompletedRes;
struct FileCompletedResDefaultTypeInternal;
extern FileCompletedResDefaultTypeInternal _FileCompletedRes_default_instance_;
class FileProgressReq;
struct FileProgressReqDefaultTypeInternal;
extern FileProgressReqDefaultTypeInternal _FileProgressReq_default_instance_;
class FileProgressRes;
struct FileProgressResDefaultTypeInternal;
extern FileProgressResDefaultTypeInternal _FileProgressRes_default_instance_;
class GetBtStatusReq;
struct GetBtStatusReqDefaultTypeInternal;
extern GetBtStatusReqDefaultTypeInternal _GetBtStatusReq_default_instance_;
class GetBtStatusRsp;
struct GetBtStatusRspDefaultTypeInternal;
extern GetBtStatusRspDefaultTypeInternal _GetBtStatusRsp_default_instance_;
class GetMagnetUriReq;
struct GetMagnetUriReqDefaultTypeInternal;
extern GetMagnetUriReqDefaultTypeInternal _GetMagnetUriReq_default_instance_;
class GetMagnetUriRsp;
struct GetMagnetUriRspDefaultTypeInternal;
extern GetMagnetUriRspDefaultTypeInternal _GetMagnetUriRsp_default_instance_;
class GetResumeDataReq;
struct GetResumeDataReqDefaultTypeInternal;
extern GetResumeDataReqDefaultTypeInternal _GetResumeDataReq_default_instance_;
class GetResumeDataRsp;
struct GetResumeDataRspDefaultTypeInternal;
extern GetResumeDataRspDefaultTypeInternal _GetResumeDataRsp_default_instance_;
class GetSessionParamsReq;
struct GetSessionParamsReqDefaultTypeInternal;
extern GetSessionParamsReqDefaultTypeInternal _GetSessionParamsReq_default_instance_;
class GetSessionParamsRsp;
struct GetSessionParamsRspDefaultTypeInternal;
extern GetSessionParamsRspDefaultTypeInternal _GetSessionParamsRsp_default_instance_;
class GetTorrentInfoReq;
struct GetTorrentInfoReqDefaultTypeInternal;
extern GetTorrentInfoReqDefaultTypeInternal _GetTorrentInfoReq_default_instance_;
class GetTorrentInfoRsp;
struct GetTorrentInfoRspDefaultTypeInternal;
extern GetTorrentInfoRspDefaultTypeInternal _GetTorrentInfoRsp_default_instance_;
class InfoHash;
struct InfoHashDefaultTypeInternal;
extern InfoHashDefaultTypeInternal _InfoHash_default_instance_;
class InitSessionReq;
struct InitSessionReqDefaultTypeInternal;
extern InitSessionReqDefaultTypeInternal _InitSessionReq_default_instance_;
class InitSessionRsp;
struct InitSessionRspDefaultTypeInternal;
extern InitSessionRspDefaultTypeInternal _InitSessionRsp_default_instance_;
class InitedSessionReq;
struct InitedSessionReqDefaultTypeInternal;
extern InitedSessionReqDefaultTypeInternal _InitedSessionReq_default_instance_;
class InitedSessionRsp;
struct InitedSessionRspDefaultTypeInternal;
extern InitedSessionRspDefaultTypeInternal _InitedSessionRsp_default_instance_;
class RemoveTorrentReq;
struct RemoveTorrentReqDefaultTypeInternal;
extern RemoveTorrentReqDefaultTypeInternal _RemoveTorrentReq_default_instance_;
class RemoveTorrentRes;
struct RemoveTorrentResDefaultTypeInternal;
extern RemoveTorrentResDefaultTypeInternal _RemoveTorrentRes_default_instance_;
class TorrentInfo;
struct TorrentInfoDefaultTypeInternal;
extern TorrentInfoDefaultTypeInternal _TorrentInfo_default_instance_;
class TorrentInfoReq;
struct TorrentInfoReqDefaultTypeInternal;
extern TorrentInfoReqDefaultTypeInternal _TorrentInfoReq_default_instance_;
class TorrentInfoRes;
struct TorrentInfoResDefaultTypeInternal;
extern TorrentInfoResDefaultTypeInternal _TorrentInfoRes_default_instance_;
class TorrentStatus;
struct TorrentStatusDefaultTypeInternal;
extern TorrentStatusDefaultTypeInternal _TorrentStatus_default_instance_;
}  // namespace prpc
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace prpc {
enum BtFile_State : int {
  BtFile_State_stop = 0,
  BtFile_State_downloading = 1,
  BtFile_State_completed = 2,
  BtFile_State_BtFile_State_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BtFile_State_BtFile_State_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BtFile_State_IsValid(int value);
constexpr BtFile_State BtFile_State_State_MIN = static_cast<BtFile_State>(0);
constexpr BtFile_State BtFile_State_State_MAX = static_cast<BtFile_State>(2);
constexpr int BtFile_State_State_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
BtFile_State_descriptor();
template <typename T>
const std::string& BtFile_State_Name(T value) {
  static_assert(std::is_same<T, BtFile_State>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to State_Name().");
  return BtFile_State_Name(static_cast<BtFile_State>(value));
}
template <>
inline const std::string& BtFile_State_Name(BtFile_State value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BtFile_State_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool BtFile_State_Parse(absl::string_view name, BtFile_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BtFile_State>(
      BtFile_State_descriptor(), name, value);
}
enum DownloadRequest_ReqType : int {
  DownloadRequest_ReqType_MagnetUri = 0,
  DownloadRequest_ReqType_Torrent = 1,
  DownloadRequest_ReqType_Resume = 2,
  DownloadRequest_ReqType_DownloadRequest_ReqType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DownloadRequest_ReqType_DownloadRequest_ReqType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DownloadRequest_ReqType_IsValid(int value);
constexpr DownloadRequest_ReqType DownloadRequest_ReqType_ReqType_MIN = static_cast<DownloadRequest_ReqType>(0);
constexpr DownloadRequest_ReqType DownloadRequest_ReqType_ReqType_MAX = static_cast<DownloadRequest_ReqType>(2);
constexpr int DownloadRequest_ReqType_ReqType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
DownloadRequest_ReqType_descriptor();
template <typename T>
const std::string& DownloadRequest_ReqType_Name(T value) {
  static_assert(std::is_same<T, DownloadRequest_ReqType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ReqType_Name().");
  return DownloadRequest_ReqType_Name(static_cast<DownloadRequest_ReqType>(value));
}
template <>
inline const std::string& DownloadRequest_ReqType_Name(DownloadRequest_ReqType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DownloadRequest_ReqType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool DownloadRequest_ReqType_Parse(absl::string_view name, DownloadRequest_ReqType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DownloadRequest_ReqType>(
      DownloadRequest_ReqType_descriptor(), name, value);
}
enum GetMagnetUriReq_ReqType : int {
  GetMagnetUriReq_ReqType_Torrent = 0,
  GetMagnetUriReq_ReqType_InfoHash = 1,
  GetMagnetUriReq_ReqType_GetMagnetUriReq_ReqType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  GetMagnetUriReq_ReqType_GetMagnetUriReq_ReqType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool GetMagnetUriReq_ReqType_IsValid(int value);
constexpr GetMagnetUriReq_ReqType GetMagnetUriReq_ReqType_ReqType_MIN = static_cast<GetMagnetUriReq_ReqType>(0);
constexpr GetMagnetUriReq_ReqType GetMagnetUriReq_ReqType_ReqType_MAX = static_cast<GetMagnetUriReq_ReqType>(1);
constexpr int GetMagnetUriReq_ReqType_ReqType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
GetMagnetUriReq_ReqType_descriptor();
template <typename T>
const std::string& GetMagnetUriReq_ReqType_Name(T value) {
  static_assert(std::is_same<T, GetMagnetUriReq_ReqType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ReqType_Name().");
  return GetMagnetUriReq_ReqType_Name(static_cast<GetMagnetUriReq_ReqType>(value));
}
template <>
inline const std::string& GetMagnetUriReq_ReqType_Name(GetMagnetUriReq_ReqType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GetMagnetUriReq_ReqType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool GetMagnetUriReq_ReqType_Parse(absl::string_view name, GetMagnetUriReq_ReqType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GetMagnetUriReq_ReqType>(
      GetMagnetUriReq_ReqType_descriptor(), name, value);
}
enum BtStateEnum : int {
  unknown = 0,
  checking_files = 1,
  downloading_metadata = 2,
  downloading = 3,
  finished = 4,
  seeding = 5,
  checking_resume_data = 7,
  BtStateEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BtStateEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BtStateEnum_IsValid(int value);
constexpr BtStateEnum BtStateEnum_MIN = static_cast<BtStateEnum>(0);
constexpr BtStateEnum BtStateEnum_MAX = static_cast<BtStateEnum>(7);
constexpr int BtStateEnum_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
BtStateEnum_descriptor();
template <typename T>
const std::string& BtStateEnum_Name(T value) {
  static_assert(std::is_same<T, BtStateEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BtStateEnum_Name().");
  return BtStateEnum_Name(static_cast<BtStateEnum>(value));
}
template <>
inline const std::string& BtStateEnum_Name(BtStateEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BtStateEnum_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool BtStateEnum_Parse(absl::string_view name, BtStateEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BtStateEnum>(
      BtStateEnum_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class InitedSessionReq final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:prpc.InitedSessionReq) */ {
 public:
  inline InitedSessionReq() : InitedSessionReq(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InitedSessionReq(::google::protobuf::internal::ConstantInitialized);

  InitedSessionReq(const InitedSessionReq& from);
  InitedSessionReq(InitedSessionReq&& from) noexcept
    : InitedSessionReq() {
    *this = ::std::move(from);
  }

  inline InitedSessionReq& operator=(const InitedSessionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitedSessionReq& operator=(InitedSessionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitedSessionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitedSessionReq* internal_default_instance() {
    return reinterpret_cast<const InitedSessionReq*>(
               &_InitedSessionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InitedSessionReq& a, InitedSessionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(InitedSessionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitedSessionReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitedSessionReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitedSessionReq>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InitedSessionReq& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InitedSessionReq& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.InitedSessionReq";
  }
  protected:
  explicit InitedSessionReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:prpc.InitedSessionReq)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class InitedSessionRsp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.InitedSessionRsp) */ {
 public:
  inline InitedSessionRsp() : InitedSessionRsp(nullptr) {}
  ~InitedSessionRsp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InitedSessionRsp(::google::protobuf::internal::ConstantInitialized);

  InitedSessionRsp(const InitedSessionRsp& from);
  InitedSessionRsp(InitedSessionRsp&& from) noexcept
    : InitedSessionRsp() {
    *this = ::std::move(from);
  }

  inline InitedSessionRsp& operator=(const InitedSessionRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitedSessionRsp& operator=(InitedSessionRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitedSessionRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitedSessionRsp* internal_default_instance() {
    return reinterpret_cast<const InitedSessionRsp*>(
               &_InitedSessionRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InitedSessionRsp& a, InitedSessionRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(InitedSessionRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitedSessionRsp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitedSessionRsp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitedSessionRsp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InitedSessionRsp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InitedSessionRsp& from) {
    InitedSessionRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitedSessionRsp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.InitedSessionRsp";
  }
  protected:
  explicit InitedSessionRsp(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitedFieldNumber = 1,
  };
  // bool inited = 1;
  void clear_inited() ;
  bool inited() const;
  void set_inited(bool value);

  private:
  bool _internal_inited() const;
  void _internal_set_inited(bool value);

  public:
  // @@protoc_insertion_point(class_scope:prpc.InitedSessionRsp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool inited_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class InitSessionReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.InitSessionReq) */ {
 public:
  inline InitSessionReq() : InitSessionReq(nullptr) {}
  ~InitSessionReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InitSessionReq(::google::protobuf::internal::ConstantInitialized);

  InitSessionReq(const InitSessionReq& from);
  InitSessionReq(InitSessionReq&& from) noexcept
    : InitSessionReq() {
    *this = ::std::move(from);
  }

  inline InitSessionReq& operator=(const InitSessionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitSessionReq& operator=(InitSessionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitSessionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitSessionReq* internal_default_instance() {
    return reinterpret_cast<const InitSessionReq*>(
               &_InitSessionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InitSessionReq& a, InitSessionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(InitSessionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitSessionReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitSessionReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitSessionReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InitSessionReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InitSessionReq& from) {
    InitSessionReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitSessionReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.InitSessionReq";
  }
  protected:
  explicit InitSessionReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProxyHostnameFieldNumber = 1,
    kProxyTypeFieldNumber = 3,
    kResumeDataFieldNumber = 7,
    kProxyPortFieldNumber = 2,
    kUploadRateLimitFieldNumber = 4,
    kDownloadRateLimitFieldNumber = 5,
    kHashingThreadsFieldNumber = 6,
  };
  // string proxy_hostname = 1;
  void clear_proxy_hostname() ;
  const std::string& proxy_hostname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proxy_hostname(Arg_&& arg, Args_... args);
  std::string* mutable_proxy_hostname();
  PROTOBUF_NODISCARD std::string* release_proxy_hostname();
  void set_allocated_proxy_hostname(std::string* ptr);

  private:
  const std::string& _internal_proxy_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proxy_hostname(
      const std::string& value);
  std::string* _internal_mutable_proxy_hostname();

  public:
  // string proxy_type = 3;
  void clear_proxy_type() ;
  const std::string& proxy_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_proxy_type(Arg_&& arg, Args_... args);
  std::string* mutable_proxy_type();
  PROTOBUF_NODISCARD std::string* release_proxy_type();
  void set_allocated_proxy_type(std::string* ptr);

  private:
  const std::string& _internal_proxy_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_proxy_type(
      const std::string& value);
  std::string* _internal_mutable_proxy_type();

  public:
  // bytes resume_data = 7;
  void clear_resume_data() ;
  const std::string& resume_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_resume_data(Arg_&& arg, Args_... args);
  std::string* mutable_resume_data();
  PROTOBUF_NODISCARD std::string* release_resume_data();
  void set_allocated_resume_data(std::string* ptr);

  private:
  const std::string& _internal_resume_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resume_data(
      const std::string& value);
  std::string* _internal_mutable_resume_data();

  public:
  // int32 proxy_port = 2;
  void clear_proxy_port() ;
  ::int32_t proxy_port() const;
  void set_proxy_port(::int32_t value);

  private:
  ::int32_t _internal_proxy_port() const;
  void _internal_set_proxy_port(::int32_t value);

  public:
  // int32 upload_rate_limit = 4;
  void clear_upload_rate_limit() ;
  ::int32_t upload_rate_limit() const;
  void set_upload_rate_limit(::int32_t value);

  private:
  ::int32_t _internal_upload_rate_limit() const;
  void _internal_set_upload_rate_limit(::int32_t value);

  public:
  // int32 download_rate_limit = 5;
  void clear_download_rate_limit() ;
  ::int32_t download_rate_limit() const;
  void set_download_rate_limit(::int32_t value);

  private:
  ::int32_t _internal_download_rate_limit() const;
  void _internal_set_download_rate_limit(::int32_t value);

  public:
  // int32 hashing_threads = 6;
  void clear_hashing_threads() ;
  ::int32_t hashing_threads() const;
  void set_hashing_threads(::int32_t value);

  private:
  ::int32_t _internal_hashing_threads() const;
  void _internal_set_hashing_threads(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:prpc.InitSessionReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 0, 52, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr proxy_hostname_;
    ::google::protobuf::internal::ArenaStringPtr proxy_type_;
    ::google::protobuf::internal::ArenaStringPtr resume_data_;
    ::int32_t proxy_port_;
    ::int32_t upload_rate_limit_;
    ::int32_t download_rate_limit_;
    ::int32_t hashing_threads_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class InitSessionRsp final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:prpc.InitSessionRsp) */ {
 public:
  inline InitSessionRsp() : InitSessionRsp(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InitSessionRsp(::google::protobuf::internal::ConstantInitialized);

  InitSessionRsp(const InitSessionRsp& from);
  InitSessionRsp(InitSessionRsp&& from) noexcept
    : InitSessionRsp() {
    *this = ::std::move(from);
  }

  inline InitSessionRsp& operator=(const InitSessionRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitSessionRsp& operator=(InitSessionRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitSessionRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitSessionRsp* internal_default_instance() {
    return reinterpret_cast<const InitSessionRsp*>(
               &_InitSessionRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InitSessionRsp& a, InitSessionRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(InitSessionRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitSessionRsp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitSessionRsp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitSessionRsp>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InitSessionRsp& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InitSessionRsp& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.InitSessionRsp";
  }
  protected:
  explicit InitSessionRsp(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:prpc.InitSessionRsp)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class BtFile final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.BtFile) */ {
 public:
  inline BtFile() : BtFile(nullptr) {}
  ~BtFile() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BtFile(::google::protobuf::internal::ConstantInitialized);

  BtFile(const BtFile& from);
  BtFile(BtFile&& from) noexcept
    : BtFile() {
    *this = ::std::move(from);
  }

  inline BtFile& operator=(const BtFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline BtFile& operator=(BtFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BtFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const BtFile* internal_default_instance() {
    return reinterpret_cast<const BtFile*>(
               &_BtFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BtFile& a, BtFile& b) {
    a.Swap(&b);
  }
  inline void Swap(BtFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BtFile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BtFile* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BtFile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BtFile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BtFile& from) {
    BtFile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BtFile* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.BtFile";
  }
  protected:
  explicit BtFile(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using State = BtFile_State;
  static constexpr State stop = BtFile_State_stop;
  static constexpr State downloading = BtFile_State_downloading;
  static constexpr State completed = BtFile_State_completed;
  static inline bool State_IsValid(int value) {
    return BtFile_State_IsValid(value);
  }
  static constexpr State State_MIN = BtFile_State_State_MIN;
  static constexpr State State_MAX = BtFile_State_State_MAX;
  static constexpr int State_ARRAYSIZE = BtFile_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* State_descriptor() {
    return BtFile_State_descriptor();
  }
  template <typename T>
  static inline const std::string& State_Name(T value) {
    return BtFile_State_Name(value);
  }
  static inline bool State_Parse(absl::string_view name, State* value) {
    return BtFile_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIndexFieldNumber = 2,
    kStFieldNumber = 3,
    kTotalSizeFieldNumber = 4,
    kDownloadedFieldNumber = 5,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // int32 index = 2;
  void clear_index() ;
  ::int32_t index() const;
  void set_index(::int32_t value);

  private:
  ::int32_t _internal_index() const;
  void _internal_set_index(::int32_t value);

  public:
  // .prpc.BtFile.State st = 3;
  void clear_st() ;
  ::prpc::BtFile_State st() const;
  void set_st(::prpc::BtFile_State value);

  private:
  ::prpc::BtFile_State _internal_st() const;
  void _internal_set_st(::prpc::BtFile_State value);

  public:
  // int64 total_size = 4;
  void clear_total_size() ;
  ::int64_t total_size() const;
  void set_total_size(::int64_t value);

  private:
  ::int64_t _internal_total_size() const;
  void _internal_set_total_size(::int64_t value);

  public:
  // int64 downloaded = 5;
  void clear_downloaded() ;
  ::int64_t downloaded() const;
  void set_downloaded(::int64_t value);

  private:
  ::int64_t _internal_downloaded() const;
  void _internal_set_downloaded(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:prpc.BtFile)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5, 0, 24, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t index_;
    int st_;
    ::int64_t total_size_;
    ::int64_t downloaded_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class TorrentInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.TorrentInfo) */ {
 public:
  inline TorrentInfo() : TorrentInfo(nullptr) {}
  ~TorrentInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TorrentInfo(::google::protobuf::internal::ConstantInitialized);

  TorrentInfo(const TorrentInfo& from);
  TorrentInfo(TorrentInfo&& from) noexcept
    : TorrentInfo() {
    *this = ::std::move(from);
  }

  inline TorrentInfo& operator=(const TorrentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TorrentInfo& operator=(TorrentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TorrentInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TorrentInfo* internal_default_instance() {
    return reinterpret_cast<const TorrentInfo*>(
               &_TorrentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TorrentInfo& a, TorrentInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TorrentInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TorrentInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TorrentInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TorrentInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TorrentInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TorrentInfo& from) {
    TorrentInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TorrentInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.TorrentInfo";
  }
  protected:
  explicit TorrentInfo(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 4,
    kNameFieldNumber = 2,
    kSavePathFieldNumber = 3,
    kInfoHashFieldNumber = 1,
    kTotalSizeFieldNumber = 5,
    kPieceLengthFieldNumber = 6,
    kNumPiecesFieldNumber = 7,
  };
  // repeated .prpc.BtFile files = 4;
  int files_size() const;
  private:
  int _internal_files_size() const;

  public:
  void clear_files() ;
  ::prpc::BtFile* mutable_files(int index);
  ::google::protobuf::RepeatedPtrField< ::prpc::BtFile >*
      mutable_files();
  private:
  const ::google::protobuf::RepeatedPtrField<::prpc::BtFile>& _internal_files() const;
  ::google::protobuf::RepeatedPtrField<::prpc::BtFile>* _internal_mutable_files();
  public:
  const ::prpc::BtFile& files(int index) const;
  ::prpc::BtFile* add_files();
  const ::google::protobuf::RepeatedPtrField< ::prpc::BtFile >&
      files() const;
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string save_path = 3;
  void clear_save_path() ;
  const std::string& save_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_save_path(Arg_&& arg, Args_... args);
  std::string* mutable_save_path();
  PROTOBUF_NODISCARD std::string* release_save_path();
  void set_allocated_save_path(std::string* ptr);

  private:
  const std::string& _internal_save_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_save_path(
      const std::string& value);
  std::string* _internal_mutable_save_path();

  public:
  // .prpc.InfoHash info_hash = 1;
  bool has_info_hash() const;
  void clear_info_hash() ;
  const ::prpc::InfoHash& info_hash() const;
  PROTOBUF_NODISCARD ::prpc::InfoHash* release_info_hash();
  ::prpc::InfoHash* mutable_info_hash();
  void set_allocated_info_hash(::prpc::InfoHash* value);
  void unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value);
  ::prpc::InfoHash* unsafe_arena_release_info_hash();

  private:
  const ::prpc::InfoHash& _internal_info_hash() const;
  ::prpc::InfoHash* _internal_mutable_info_hash();

  public:
  // int64 total_size = 5;
  void clear_total_size() ;
  ::int64_t total_size() const;
  void set_total_size(::int64_t value);

  private:
  ::int64_t _internal_total_size() const;
  void _internal_set_total_size(::int64_t value);

  public:
  // int32 piece_length = 6;
  void clear_piece_length() ;
  ::int32_t piece_length() const;
  void set_piece_length(::int32_t value);

  private:
  ::int32_t _internal_piece_length() const;
  void _internal_set_piece_length(::int32_t value);

  public:
  // int32 num_pieces = 7;
  void clear_num_pieces() ;
  ::int32_t num_pieces() const;
  void set_num_pieces(::int32_t value);

  private:
  ::int32_t _internal_num_pieces() const;
  void _internal_set_num_pieces(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:prpc.TorrentInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7, 2, 38, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::prpc::BtFile > files_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr save_path_;
    ::prpc::InfoHash* info_hash_;
    ::int64_t total_size_;
    ::int32_t piece_length_;
    ::int32_t num_pieces_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class TorrentStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.TorrentStatus) */ {
 public:
  inline TorrentStatus() : TorrentStatus(nullptr) {}
  ~TorrentStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TorrentStatus(::google::protobuf::internal::ConstantInitialized);

  TorrentStatus(const TorrentStatus& from);
  TorrentStatus(TorrentStatus&& from) noexcept
    : TorrentStatus() {
    *this = ::std::move(from);
  }

  inline TorrentStatus& operator=(const TorrentStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TorrentStatus& operator=(TorrentStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TorrentStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const TorrentStatus* internal_default_instance() {
    return reinterpret_cast<const TorrentStatus*>(
               &_TorrentStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TorrentStatus& a, TorrentStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(TorrentStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TorrentStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TorrentStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TorrentStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TorrentStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TorrentStatus& from) {
    TorrentStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TorrentStatus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.TorrentStatus";
  }
  protected:
  explicit TorrentStatus(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kInfoHashFieldNumber = 1,
    kTotalDoneFieldNumber = 4,
    kDownloadPayloadRateFieldNumber = 3,
    kProgressFieldNumber = 6,
    kTotalFieldNumber = 5,
    kNumPeersFieldNumber = 7,
    kStateFieldNumber = 8,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .prpc.InfoHash info_hash = 1;
  bool has_info_hash() const;
  void clear_info_hash() ;
  const ::prpc::InfoHash& info_hash() const;
  PROTOBUF_NODISCARD ::prpc::InfoHash* release_info_hash();
  ::prpc::InfoHash* mutable_info_hash();
  void set_allocated_info_hash(::prpc::InfoHash* value);
  void unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value);
  ::prpc::InfoHash* unsafe_arena_release_info_hash();

  private:
  const ::prpc::InfoHash& _internal_info_hash() const;
  ::prpc::InfoHash* _internal_mutable_info_hash();

  public:
  // int64 total_done = 4;
  void clear_total_done() ;
  ::int64_t total_done() const;
  void set_total_done(::int64_t value);

  private:
  ::int64_t _internal_total_done() const;
  void _internal_set_total_done(::int64_t value);

  public:
  // int32 download_payload_rate = 3;
  void clear_download_payload_rate() ;
  ::int32_t download_payload_rate() const;
  void set_download_payload_rate(::int32_t value);

  private:
  ::int32_t _internal_download_payload_rate() const;
  void _internal_set_download_payload_rate(::int32_t value);

  public:
  // float progress = 6;
  void clear_progress() ;
  float progress() const;
  void set_progress(float value);

  private:
  float _internal_progress() const;
  void _internal_set_progress(float value);

  public:
  // int64 total = 5;
  void clear_total() ;
  ::int64_t total() const;
  void set_total(::int64_t value);

  private:
  ::int64_t _internal_total() const;
  void _internal_set_total(::int64_t value);

  public:
  // int32 num_peers = 7;
  void clear_num_peers() ;
  ::int32_t num_peers() const;
  void set_num_peers(::int32_t value);

  private:
  ::int32_t _internal_num_peers() const;
  void _internal_set_num_peers(::int32_t value);

  public:
  // .prpc.BtStateEnum state = 8;
  void clear_state() ;
  ::prpc::BtStateEnum state() const;
  void set_state(::prpc::BtStateEnum value);

  private:
  ::prpc::BtStateEnum _internal_state() const;
  void _internal_set_state(::prpc::BtStateEnum value);

  public:
  // @@protoc_insertion_point(class_scope:prpc.TorrentStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 8, 1, 39, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::prpc::InfoHash* info_hash_;
    ::int64_t total_done_;
    ::int32_t download_payload_rate_;
    float progress_;
    ::int64_t total_;
    ::int32_t num_peers_;
    int state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class DownloadRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.DownloadRequest) */ {
 public:
  inline DownloadRequest() : DownloadRequest(nullptr) {}
  ~DownloadRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DownloadRequest(::google::protobuf::internal::ConstantInitialized);

  DownloadRequest(const DownloadRequest& from);
  DownloadRequest(DownloadRequest&& from) noexcept
    : DownloadRequest() {
    *this = ::std::move(from);
  }

  inline DownloadRequest& operator=(const DownloadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadRequest& operator=(DownloadRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadRequest* internal_default_instance() {
    return reinterpret_cast<const DownloadRequest*>(
               &_DownloadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DownloadRequest& a, DownloadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DownloadRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DownloadRequest& from) {
    DownloadRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.DownloadRequest";
  }
  protected:
  explicit DownloadRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ReqType = DownloadRequest_ReqType;
  static constexpr ReqType MagnetUri = DownloadRequest_ReqType_MagnetUri;
  static constexpr ReqType Torrent = DownloadRequest_ReqType_Torrent;
  static constexpr ReqType Resume = DownloadRequest_ReqType_Resume;
  static inline bool ReqType_IsValid(int value) {
    return DownloadRequest_ReqType_IsValid(value);
  }
  static constexpr ReqType ReqType_MIN = DownloadRequest_ReqType_ReqType_MIN;
  static constexpr ReqType ReqType_MAX = DownloadRequest_ReqType_ReqType_MAX;
  static constexpr int ReqType_ARRAYSIZE = DownloadRequest_ReqType_ReqType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ReqType_descriptor() {
    return DownloadRequest_ReqType_descriptor();
  }
  template <typename T>
  static inline const std::string& ReqType_Name(T value) {
    return DownloadRequest_ReqType_Name(value);
  }
  static inline bool ReqType_Parse(absl::string_view name, ReqType* value) {
    return DownloadRequest_ReqType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kSavePathFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // bytes content = 2;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* ptr);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // string save_path = 3;
  void clear_save_path() ;
  const std::string& save_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_save_path(Arg_&& arg, Args_... args);
  std::string* mutable_save_path();
  PROTOBUF_NODISCARD std::string* release_save_path();
  void set_allocated_save_path(std::string* ptr);

  private:
  const std::string& _internal_save_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_save_path(
      const std::string& value);
  std::string* _internal_mutable_save_path();

  public:
  // .prpc.DownloadRequest.ReqType type = 1;
  void clear_type() ;
  ::prpc::DownloadRequest_ReqType type() const;
  void set_type(::prpc::DownloadRequest_ReqType value);

  private:
  ::prpc::DownloadRequest_ReqType _internal_type() const;
  void _internal_set_type(::prpc::DownloadRequest_ReqType value);

  public:
  // @@protoc_insertion_point(class_scope:prpc.DownloadRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 38, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr content_;
    ::google::protobuf::internal::ArenaStringPtr save_path_;
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class InfoHash final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.InfoHash) */ {
 public:
  inline InfoHash() : InfoHash(nullptr) {}
  ~InfoHash() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InfoHash(::google::protobuf::internal::ConstantInitialized);

  InfoHash(const InfoHash& from);
  InfoHash(InfoHash&& from) noexcept
    : InfoHash() {
    *this = ::std::move(from);
  }

  inline InfoHash& operator=(const InfoHash& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoHash& operator=(InfoHash&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InfoHash& default_instance() {
    return *internal_default_instance();
  }
  static inline const InfoHash* internal_default_instance() {
    return reinterpret_cast<const InfoHash*>(
               &_InfoHash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InfoHash& a, InfoHash& b) {
    a.Swap(&b);
  }
  inline void Swap(InfoHash* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfoHash* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InfoHash* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InfoHash>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InfoHash& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InfoHash& from) {
    InfoHash::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InfoHash* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.InfoHash";
  }
  protected:
  explicit InfoHash(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 2,
    kVersionFieldNumber = 1,
  };
  // bytes hash = 2;
  void clear_hash() ;
  const std::string& hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* ptr);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // int32 version = 1;
  void clear_version() ;
  ::int32_t version() const;
  void set_version(::int32_t value);

  private:
  ::int32_t _internal_version() const;
  void _internal_set_version(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:prpc.InfoHash)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr hash_;
    ::int32_t version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class DownloadRespone final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.DownloadRespone) */ {
 public:
  inline DownloadRespone() : DownloadRespone(nullptr) {}
  ~DownloadRespone() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DownloadRespone(::google::protobuf::internal::ConstantInitialized);

  DownloadRespone(const DownloadRespone& from);
  DownloadRespone(DownloadRespone&& from) noexcept
    : DownloadRespone() {
    *this = ::std::move(from);
  }

  inline DownloadRespone& operator=(const DownloadRespone& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadRespone& operator=(DownloadRespone&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DownloadRespone& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadRespone* internal_default_instance() {
    return reinterpret_cast<const DownloadRespone*>(
               &_DownloadRespone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DownloadRespone& a, DownloadRespone& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadRespone* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadRespone* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadRespone* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadRespone>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DownloadRespone& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DownloadRespone& from) {
    DownloadRespone::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DownloadRespone* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.DownloadRespone";
  }
  protected:
  explicit DownloadRespone(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoHashFieldNumber = 1,
  };
  // .prpc.InfoHash info_hash = 1;
  bool has_info_hash() const;
  void clear_info_hash() ;
  const ::prpc::InfoHash& info_hash() const;
  PROTOBUF_NODISCARD ::prpc::InfoHash* release_info_hash();
  ::prpc::InfoHash* mutable_info_hash();
  void set_allocated_info_hash(::prpc::InfoHash* value);
  void unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value);
  ::prpc::InfoHash* unsafe_arena_release_info_hash();

  private:
  const ::prpc::InfoHash& _internal_info_hash() const;
  ::prpc::InfoHash* _internal_mutable_info_hash();

  public:
  // @@protoc_insertion_point(class_scope:prpc.DownloadRespone)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::prpc::InfoHash* info_hash_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class GetMagnetUriReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.GetMagnetUriReq) */ {
 public:
  inline GetMagnetUriReq() : GetMagnetUriReq(nullptr) {}
  ~GetMagnetUriReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetMagnetUriReq(::google::protobuf::internal::ConstantInitialized);

  GetMagnetUriReq(const GetMagnetUriReq& from);
  GetMagnetUriReq(GetMagnetUriReq&& from) noexcept
    : GetMagnetUriReq() {
    *this = ::std::move(from);
  }

  inline GetMagnetUriReq& operator=(const GetMagnetUriReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMagnetUriReq& operator=(GetMagnetUriReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMagnetUriReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMagnetUriReq* internal_default_instance() {
    return reinterpret_cast<const GetMagnetUriReq*>(
               &_GetMagnetUriReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetMagnetUriReq& a, GetMagnetUriReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMagnetUriReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMagnetUriReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMagnetUriReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMagnetUriReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetMagnetUriReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetMagnetUriReq& from) {
    GetMagnetUriReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMagnetUriReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.GetMagnetUriReq";
  }
  protected:
  explicit GetMagnetUriReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ReqType = GetMagnetUriReq_ReqType;
  static constexpr ReqType Torrent = GetMagnetUriReq_ReqType_Torrent;
  static constexpr ReqType InfoHash = GetMagnetUriReq_ReqType_InfoHash;
  static inline bool ReqType_IsValid(int value) {
    return GetMagnetUriReq_ReqType_IsValid(value);
  }
  static constexpr ReqType ReqType_MIN = GetMagnetUriReq_ReqType_ReqType_MIN;
  static constexpr ReqType ReqType_MAX = GetMagnetUriReq_ReqType_ReqType_MAX;
  static constexpr int ReqType_ARRAYSIZE = GetMagnetUriReq_ReqType_ReqType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ReqType_descriptor() {
    return GetMagnetUriReq_ReqType_descriptor();
  }
  template <typename T>
  static inline const std::string& ReqType_Name(T value) {
    return GetMagnetUriReq_ReqType_Name(value);
  }
  static inline bool ReqType_Parse(absl::string_view name, ReqType* value) {
    return GetMagnetUriReq_ReqType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kInfoHashFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // bytes content = 2;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* ptr);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // .prpc.InfoHash info_hash = 3;
  bool has_info_hash() const;
  void clear_info_hash() ;
  const ::prpc::InfoHash& info_hash() const;
  PROTOBUF_NODISCARD ::prpc::InfoHash* release_info_hash();
  ::prpc::InfoHash* mutable_info_hash();
  void set_allocated_info_hash(::prpc::InfoHash* value);
  void unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value);
  ::prpc::InfoHash* unsafe_arena_release_info_hash();

  private:
  const ::prpc::InfoHash& _internal_info_hash() const;
  ::prpc::InfoHash* _internal_mutable_info_hash();

  public:
  // .prpc.GetMagnetUriReq.ReqType type = 1;
  void clear_type() ;
  ::prpc::GetMagnetUriReq_ReqType type() const;
  void set_type(::prpc::GetMagnetUriReq_ReqType value);

  private:
  ::prpc::GetMagnetUriReq_ReqType _internal_type() const;
  void _internal_set_type(::prpc::GetMagnetUriReq_ReqType value);

  public:
  // @@protoc_insertion_point(class_scope:prpc.GetMagnetUriReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr content_;
    ::prpc::InfoHash* info_hash_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class GetMagnetUriRsp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.GetMagnetUriRsp) */ {
 public:
  inline GetMagnetUriRsp() : GetMagnetUriRsp(nullptr) {}
  ~GetMagnetUriRsp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetMagnetUriRsp(::google::protobuf::internal::ConstantInitialized);

  GetMagnetUriRsp(const GetMagnetUriRsp& from);
  GetMagnetUriRsp(GetMagnetUriRsp&& from) noexcept
    : GetMagnetUriRsp() {
    *this = ::std::move(from);
  }

  inline GetMagnetUriRsp& operator=(const GetMagnetUriRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMagnetUriRsp& operator=(GetMagnetUriRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMagnetUriRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMagnetUriRsp* internal_default_instance() {
    return reinterpret_cast<const GetMagnetUriRsp*>(
               &_GetMagnetUriRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetMagnetUriRsp& a, GetMagnetUriRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMagnetUriRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMagnetUriRsp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMagnetUriRsp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMagnetUriRsp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetMagnetUriRsp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetMagnetUriRsp& from) {
    GetMagnetUriRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMagnetUriRsp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.GetMagnetUriRsp";
  }
  protected:
  explicit GetMagnetUriRsp(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMagnetUriFieldNumber = 2,
    kInfoHashFieldNumber = 1,
  };
  // string magnet_uri = 2;
  void clear_magnet_uri() ;
  const std::string& magnet_uri() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_magnet_uri(Arg_&& arg, Args_... args);
  std::string* mutable_magnet_uri();
  PROTOBUF_NODISCARD std::string* release_magnet_uri();
  void set_allocated_magnet_uri(std::string* ptr);

  private:
  const std::string& _internal_magnet_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_magnet_uri(
      const std::string& value);
  std::string* _internal_mutable_magnet_uri();

  public:
  // .prpc.InfoHash info_hash = 1;
  bool has_info_hash() const;
  void clear_info_hash() ;
  const ::prpc::InfoHash& info_hash() const;
  PROTOBUF_NODISCARD ::prpc::InfoHash* release_info_hash();
  ::prpc::InfoHash* mutable_info_hash();
  void set_allocated_info_hash(::prpc::InfoHash* value);
  void unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value);
  ::prpc::InfoHash* unsafe_arena_release_info_hash();

  private:
  const ::prpc::InfoHash& _internal_info_hash() const;
  ::prpc::InfoHash* _internal_mutable_info_hash();

  public:
  // @@protoc_insertion_point(class_scope:prpc.GetMagnetUriRsp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 39, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr magnet_uri_;
    ::prpc::InfoHash* info_hash_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class GetResumeDataReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.GetResumeDataReq) */ {
 public:
  inline GetResumeDataReq() : GetResumeDataReq(nullptr) {}
  ~GetResumeDataReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetResumeDataReq(::google::protobuf::internal::ConstantInitialized);

  GetResumeDataReq(const GetResumeDataReq& from);
  GetResumeDataReq(GetResumeDataReq&& from) noexcept
    : GetResumeDataReq() {
    *this = ::std::move(from);
  }

  inline GetResumeDataReq& operator=(const GetResumeDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResumeDataReq& operator=(GetResumeDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResumeDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResumeDataReq* internal_default_instance() {
    return reinterpret_cast<const GetResumeDataReq*>(
               &_GetResumeDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetResumeDataReq& a, GetResumeDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResumeDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResumeDataReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResumeDataReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResumeDataReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetResumeDataReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetResumeDataReq& from) {
    GetResumeDataReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResumeDataReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.GetResumeDataReq";
  }
  protected:
  explicit GetResumeDataReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoHashFieldNumber = 1,
  };
  // .prpc.InfoHash info_hash = 1;
  bool has_info_hash() const;
  void clear_info_hash() ;
  const ::prpc::InfoHash& info_hash() const;
  PROTOBUF_NODISCARD ::prpc::InfoHash* release_info_hash();
  ::prpc::InfoHash* mutable_info_hash();
  void set_allocated_info_hash(::prpc::InfoHash* value);
  void unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value);
  ::prpc::InfoHash* unsafe_arena_release_info_hash();

  private:
  const ::prpc::InfoHash& _internal_info_hash() const;
  ::prpc::InfoHash* _internal_mutable_info_hash();

  public:
  // @@protoc_insertion_point(class_scope:prpc.GetResumeDataReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::prpc::InfoHash* info_hash_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class GetResumeDataRsp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.GetResumeDataRsp) */ {
 public:
  inline GetResumeDataRsp() : GetResumeDataRsp(nullptr) {}
  ~GetResumeDataRsp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetResumeDataRsp(::google::protobuf::internal::ConstantInitialized);

  GetResumeDataRsp(const GetResumeDataRsp& from);
  GetResumeDataRsp(GetResumeDataRsp&& from) noexcept
    : GetResumeDataRsp() {
    *this = ::std::move(from);
  }

  inline GetResumeDataRsp& operator=(const GetResumeDataRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResumeDataRsp& operator=(GetResumeDataRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetResumeDataRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetResumeDataRsp* internal_default_instance() {
    return reinterpret_cast<const GetResumeDataRsp*>(
               &_GetResumeDataRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetResumeDataRsp& a, GetResumeDataRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResumeDataRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetResumeDataRsp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetResumeDataRsp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetResumeDataRsp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetResumeDataRsp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetResumeDataRsp& from) {
    GetResumeDataRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResumeDataRsp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.GetResumeDataRsp";
  }
  protected:
  explicit GetResumeDataRsp(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResumeDataFieldNumber = 1,
  };
  // bytes resume_data = 1;
  void clear_resume_data() ;
  const std::string& resume_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_resume_data(Arg_&& arg, Args_... args);
  std::string* mutable_resume_data();
  PROTOBUF_NODISCARD std::string* release_resume_data();
  void set_allocated_resume_data(std::string* ptr);

  private:
  const std::string& _internal_resume_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resume_data(
      const std::string& value);
  std::string* _internal_mutable_resume_data();

  public:
  // @@protoc_insertion_point(class_scope:prpc.GetResumeDataRsp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr resume_data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class GetTorrentInfoReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.GetTorrentInfoReq) */ {
 public:
  inline GetTorrentInfoReq() : GetTorrentInfoReq(nullptr) {}
  ~GetTorrentInfoReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetTorrentInfoReq(::google::protobuf::internal::ConstantInitialized);

  GetTorrentInfoReq(const GetTorrentInfoReq& from);
  GetTorrentInfoReq(GetTorrentInfoReq&& from) noexcept
    : GetTorrentInfoReq() {
    *this = ::std::move(from);
  }

  inline GetTorrentInfoReq& operator=(const GetTorrentInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTorrentInfoReq& operator=(GetTorrentInfoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTorrentInfoReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTorrentInfoReq* internal_default_instance() {
    return reinterpret_cast<const GetTorrentInfoReq*>(
               &_GetTorrentInfoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetTorrentInfoReq& a, GetTorrentInfoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTorrentInfoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTorrentInfoReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTorrentInfoReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTorrentInfoReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTorrentInfoReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetTorrentInfoReq& from) {
    GetTorrentInfoReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTorrentInfoReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.GetTorrentInfoReq";
  }
  protected:
  explicit GetTorrentInfoReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoHashFieldNumber = 1,
  };
  // .prpc.InfoHash info_hash = 1;
  bool has_info_hash() const;
  void clear_info_hash() ;
  const ::prpc::InfoHash& info_hash() const;
  PROTOBUF_NODISCARD ::prpc::InfoHash* release_info_hash();
  ::prpc::InfoHash* mutable_info_hash();
  void set_allocated_info_hash(::prpc::InfoHash* value);
  void unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value);
  ::prpc::InfoHash* unsafe_arena_release_info_hash();

  private:
  const ::prpc::InfoHash& _internal_info_hash() const;
  ::prpc::InfoHash* _internal_mutable_info_hash();

  public:
  // @@protoc_insertion_point(class_scope:prpc.GetTorrentInfoReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::prpc::InfoHash* info_hash_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class GetTorrentInfoRsp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.GetTorrentInfoRsp) */ {
 public:
  inline GetTorrentInfoRsp() : GetTorrentInfoRsp(nullptr) {}
  ~GetTorrentInfoRsp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetTorrentInfoRsp(::google::protobuf::internal::ConstantInitialized);

  GetTorrentInfoRsp(const GetTorrentInfoRsp& from);
  GetTorrentInfoRsp(GetTorrentInfoRsp&& from) noexcept
    : GetTorrentInfoRsp() {
    *this = ::std::move(from);
  }

  inline GetTorrentInfoRsp& operator=(const GetTorrentInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTorrentInfoRsp& operator=(GetTorrentInfoRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTorrentInfoRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTorrentInfoRsp* internal_default_instance() {
    return reinterpret_cast<const GetTorrentInfoRsp*>(
               &_GetTorrentInfoRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetTorrentInfoRsp& a, GetTorrentInfoRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTorrentInfoRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTorrentInfoRsp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTorrentInfoRsp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTorrentInfoRsp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetTorrentInfoRsp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetTorrentInfoRsp& from) {
    GetTorrentInfoRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTorrentInfoRsp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.GetTorrentInfoRsp";
  }
  protected:
  explicit GetTorrentInfoRsp(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTorrentInfoFieldNumber = 1,
  };
  // .prpc.TorrentInfo torrent_info = 1;
  bool has_torrent_info() const;
  void clear_torrent_info() ;
  const ::prpc::TorrentInfo& torrent_info() const;
  PROTOBUF_NODISCARD ::prpc::TorrentInfo* release_torrent_info();
  ::prpc::TorrentInfo* mutable_torrent_info();
  void set_allocated_torrent_info(::prpc::TorrentInfo* value);
  void unsafe_arena_set_allocated_torrent_info(::prpc::TorrentInfo* value);
  ::prpc::TorrentInfo* unsafe_arena_release_torrent_info();

  private:
  const ::prpc::TorrentInfo& _internal_torrent_info() const;
  ::prpc::TorrentInfo* _internal_mutable_torrent_info();

  public:
  // @@protoc_insertion_point(class_scope:prpc.GetTorrentInfoRsp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::prpc::TorrentInfo* torrent_info_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class GetSessionParamsReq final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:prpc.GetSessionParamsReq) */ {
 public:
  inline GetSessionParamsReq() : GetSessionParamsReq(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetSessionParamsReq(::google::protobuf::internal::ConstantInitialized);

  GetSessionParamsReq(const GetSessionParamsReq& from);
  GetSessionParamsReq(GetSessionParamsReq&& from) noexcept
    : GetSessionParamsReq() {
    *this = ::std::move(from);
  }

  inline GetSessionParamsReq& operator=(const GetSessionParamsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSessionParamsReq& operator=(GetSessionParamsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSessionParamsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSessionParamsReq* internal_default_instance() {
    return reinterpret_cast<const GetSessionParamsReq*>(
               &_GetSessionParamsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetSessionParamsReq& a, GetSessionParamsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSessionParamsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSessionParamsReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSessionParamsReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSessionParamsReq>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetSessionParamsReq& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetSessionParamsReq& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.GetSessionParamsReq";
  }
  protected:
  explicit GetSessionParamsReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:prpc.GetSessionParamsReq)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class GetSessionParamsRsp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.GetSessionParamsRsp) */ {
 public:
  inline GetSessionParamsRsp() : GetSessionParamsRsp(nullptr) {}
  ~GetSessionParamsRsp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetSessionParamsRsp(::google::protobuf::internal::ConstantInitialized);

  GetSessionParamsRsp(const GetSessionParamsRsp& from);
  GetSessionParamsRsp(GetSessionParamsRsp&& from) noexcept
    : GetSessionParamsRsp() {
    *this = ::std::move(from);
  }

  inline GetSessionParamsRsp& operator=(const GetSessionParamsRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSessionParamsRsp& operator=(GetSessionParamsRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSessionParamsRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSessionParamsRsp* internal_default_instance() {
    return reinterpret_cast<const GetSessionParamsRsp*>(
               &_GetSessionParamsRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetSessionParamsRsp& a, GetSessionParamsRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSessionParamsRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSessionParamsRsp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSessionParamsRsp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSessionParamsRsp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetSessionParamsRsp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetSessionParamsRsp& from) {
    GetSessionParamsRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSessionParamsRsp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.GetSessionParamsRsp";
  }
  protected:
  explicit GetSessionParamsRsp(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResumeDataFieldNumber = 1,
  };
  // bytes resume_data = 1;
  void clear_resume_data() ;
  const std::string& resume_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_resume_data(Arg_&& arg, Args_... args);
  std::string* mutable_resume_data();
  PROTOBUF_NODISCARD std::string* release_resume_data();
  void set_allocated_resume_data(std::string* ptr);

  private:
  const std::string& _internal_resume_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resume_data(
      const std::string& value);
  std::string* _internal_mutable_resume_data();

  public:
  // @@protoc_insertion_point(class_scope:prpc.GetSessionParamsRsp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr resume_data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class GetBtStatusReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.GetBtStatusReq) */ {
 public:
  inline GetBtStatusReq() : GetBtStatusReq(nullptr) {}
  ~GetBtStatusReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetBtStatusReq(::google::protobuf::internal::ConstantInitialized);

  GetBtStatusReq(const GetBtStatusReq& from);
  GetBtStatusReq(GetBtStatusReq&& from) noexcept
    : GetBtStatusReq() {
    *this = ::std::move(from);
  }

  inline GetBtStatusReq& operator=(const GetBtStatusReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBtStatusReq& operator=(GetBtStatusReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBtStatusReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBtStatusReq* internal_default_instance() {
    return reinterpret_cast<const GetBtStatusReq*>(
               &_GetBtStatusReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetBtStatusReq& a, GetBtStatusReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBtStatusReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBtStatusReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBtStatusReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBtStatusReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetBtStatusReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetBtStatusReq& from) {
    GetBtStatusReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBtStatusReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.GetBtStatusReq";
  }
  protected:
  explicit GetBtStatusReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoHashFieldNumber = 1,
  };
  // .prpc.InfoHash info_hash = 1;
  bool has_info_hash() const;
  void clear_info_hash() ;
  const ::prpc::InfoHash& info_hash() const;
  PROTOBUF_NODISCARD ::prpc::InfoHash* release_info_hash();
  ::prpc::InfoHash* mutable_info_hash();
  void set_allocated_info_hash(::prpc::InfoHash* value);
  void unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value);
  ::prpc::InfoHash* unsafe_arena_release_info_hash();

  private:
  const ::prpc::InfoHash& _internal_info_hash() const;
  ::prpc::InfoHash* _internal_mutable_info_hash();

  public:
  // @@protoc_insertion_point(class_scope:prpc.GetBtStatusReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::prpc::InfoHash* info_hash_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class GetBtStatusRsp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.GetBtStatusRsp) */ {
 public:
  inline GetBtStatusRsp() : GetBtStatusRsp(nullptr) {}
  ~GetBtStatusRsp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetBtStatusRsp(::google::protobuf::internal::ConstantInitialized);

  GetBtStatusRsp(const GetBtStatusRsp& from);
  GetBtStatusRsp(GetBtStatusRsp&& from) noexcept
    : GetBtStatusRsp() {
    *this = ::std::move(from);
  }

  inline GetBtStatusRsp& operator=(const GetBtStatusRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBtStatusRsp& operator=(GetBtStatusRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBtStatusRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBtStatusRsp* internal_default_instance() {
    return reinterpret_cast<const GetBtStatusRsp*>(
               &_GetBtStatusRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetBtStatusRsp& a, GetBtStatusRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBtStatusRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBtStatusRsp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBtStatusRsp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBtStatusRsp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetBtStatusRsp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetBtStatusRsp& from) {
    GetBtStatusRsp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBtStatusRsp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.GetBtStatusRsp";
  }
  protected:
  explicit GetBtStatusRsp(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .prpc.TorrentStatus status = 1;
  bool has_status() const;
  void clear_status() ;
  const ::prpc::TorrentStatus& status() const;
  PROTOBUF_NODISCARD ::prpc::TorrentStatus* release_status();
  ::prpc::TorrentStatus* mutable_status();
  void set_allocated_status(::prpc::TorrentStatus* value);
  void unsafe_arena_set_allocated_status(::prpc::TorrentStatus* value);
  ::prpc::TorrentStatus* unsafe_arena_release_status();

  private:
  const ::prpc::TorrentStatus& _internal_status() const;
  ::prpc::TorrentStatus* _internal_mutable_status();

  public:
  // @@protoc_insertion_point(class_scope:prpc.GetBtStatusRsp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::prpc::TorrentStatus* status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class BtStatusRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.BtStatusRequest) */ {
 public:
  inline BtStatusRequest() : BtStatusRequest(nullptr) {}
  ~BtStatusRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BtStatusRequest(::google::protobuf::internal::ConstantInitialized);

  BtStatusRequest(const BtStatusRequest& from);
  BtStatusRequest(BtStatusRequest&& from) noexcept
    : BtStatusRequest() {
    *this = ::std::move(from);
  }

  inline BtStatusRequest& operator=(const BtStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BtStatusRequest& operator=(BtStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BtStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BtStatusRequest* internal_default_instance() {
    return reinterpret_cast<const BtStatusRequest*>(
               &_BtStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BtStatusRequest& a, BtStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BtStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BtStatusRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BtStatusRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BtStatusRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BtStatusRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BtStatusRequest& from) {
    BtStatusRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BtStatusRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.BtStatusRequest";
  }
  protected:
  explicit BtStatusRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoHashFieldNumber = 1,
  };
  // repeated .prpc.InfoHash info_hash = 1;
  int info_hash_size() const;
  private:
  int _internal_info_hash_size() const;

  public:
  void clear_info_hash() ;
  ::prpc::InfoHash* mutable_info_hash(int index);
  ::google::protobuf::RepeatedPtrField< ::prpc::InfoHash >*
      mutable_info_hash();
  private:
  const ::google::protobuf::RepeatedPtrField<::prpc::InfoHash>& _internal_info_hash() const;
  ::google::protobuf::RepeatedPtrField<::prpc::InfoHash>* _internal_mutable_info_hash();
  public:
  const ::prpc::InfoHash& info_hash(int index) const;
  ::prpc::InfoHash* add_info_hash();
  const ::google::protobuf::RepeatedPtrField< ::prpc::InfoHash >&
      info_hash() const;
  // @@protoc_insertion_point(class_scope:prpc.BtStatusRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::prpc::InfoHash > info_hash_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class BtStatusRespone final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.BtStatusRespone) */ {
 public:
  inline BtStatusRespone() : BtStatusRespone(nullptr) {}
  ~BtStatusRespone() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BtStatusRespone(::google::protobuf::internal::ConstantInitialized);

  BtStatusRespone(const BtStatusRespone& from);
  BtStatusRespone(BtStatusRespone&& from) noexcept
    : BtStatusRespone() {
    *this = ::std::move(from);
  }

  inline BtStatusRespone& operator=(const BtStatusRespone& from) {
    CopyFrom(from);
    return *this;
  }
  inline BtStatusRespone& operator=(BtStatusRespone&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BtStatusRespone& default_instance() {
    return *internal_default_instance();
  }
  static inline const BtStatusRespone* internal_default_instance() {
    return reinterpret_cast<const BtStatusRespone*>(
               &_BtStatusRespone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(BtStatusRespone& a, BtStatusRespone& b) {
    a.Swap(&b);
  }
  inline void Swap(BtStatusRespone* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BtStatusRespone* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BtStatusRespone* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BtStatusRespone>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BtStatusRespone& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BtStatusRespone& from) {
    BtStatusRespone::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BtStatusRespone* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.BtStatusRespone";
  }
  protected:
  explicit BtStatusRespone(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusArrayFieldNumber = 1,
  };
  // repeated .prpc.TorrentStatus status_array = 1;
  int status_array_size() const;
  private:
  int _internal_status_array_size() const;

  public:
  void clear_status_array() ;
  ::prpc::TorrentStatus* mutable_status_array(int index);
  ::google::protobuf::RepeatedPtrField< ::prpc::TorrentStatus >*
      mutable_status_array();
  private:
  const ::google::protobuf::RepeatedPtrField<::prpc::TorrentStatus>& _internal_status_array() const;
  ::google::protobuf::RepeatedPtrField<::prpc::TorrentStatus>* _internal_mutable_status_array();
  public:
  const ::prpc::TorrentStatus& status_array(int index) const;
  ::prpc::TorrentStatus* add_status_array();
  const ::google::protobuf::RepeatedPtrField< ::prpc::TorrentStatus >&
      status_array() const;
  // @@protoc_insertion_point(class_scope:prpc.BtStatusRespone)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::prpc::TorrentStatus > status_array_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class TorrentInfoReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.TorrentInfoReq) */ {
 public:
  inline TorrentInfoReq() : TorrentInfoReq(nullptr) {}
  ~TorrentInfoReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TorrentInfoReq(::google::protobuf::internal::ConstantInitialized);

  TorrentInfoReq(const TorrentInfoReq& from);
  TorrentInfoReq(TorrentInfoReq&& from) noexcept
    : TorrentInfoReq() {
    *this = ::std::move(from);
  }

  inline TorrentInfoReq& operator=(const TorrentInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TorrentInfoReq& operator=(TorrentInfoReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TorrentInfoReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TorrentInfoReq* internal_default_instance() {
    return reinterpret_cast<const TorrentInfoReq*>(
               &_TorrentInfoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TorrentInfoReq& a, TorrentInfoReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TorrentInfoReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TorrentInfoReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TorrentInfoReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TorrentInfoReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TorrentInfoReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TorrentInfoReq& from) {
    TorrentInfoReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TorrentInfoReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.TorrentInfoReq";
  }
  protected:
  explicit TorrentInfoReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoHashFieldNumber = 1,
  };
  // repeated .prpc.InfoHash info_hash = 1;
  int info_hash_size() const;
  private:
  int _internal_info_hash_size() const;

  public:
  void clear_info_hash() ;
  ::prpc::InfoHash* mutable_info_hash(int index);
  ::google::protobuf::RepeatedPtrField< ::prpc::InfoHash >*
      mutable_info_hash();
  private:
  const ::google::protobuf::RepeatedPtrField<::prpc::InfoHash>& _internal_info_hash() const;
  ::google::protobuf::RepeatedPtrField<::prpc::InfoHash>* _internal_mutable_info_hash();
  public:
  const ::prpc::InfoHash& info_hash(int index) const;
  ::prpc::InfoHash* add_info_hash();
  const ::google::protobuf::RepeatedPtrField< ::prpc::InfoHash >&
      info_hash() const;
  // @@protoc_insertion_point(class_scope:prpc.TorrentInfoReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::prpc::InfoHash > info_hash_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class TorrentInfoRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.TorrentInfoRes) */ {
 public:
  inline TorrentInfoRes() : TorrentInfoRes(nullptr) {}
  ~TorrentInfoRes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TorrentInfoRes(::google::protobuf::internal::ConstantInitialized);

  TorrentInfoRes(const TorrentInfoRes& from);
  TorrentInfoRes(TorrentInfoRes&& from) noexcept
    : TorrentInfoRes() {
    *this = ::std::move(from);
  }

  inline TorrentInfoRes& operator=(const TorrentInfoRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline TorrentInfoRes& operator=(TorrentInfoRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TorrentInfoRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const TorrentInfoRes* internal_default_instance() {
    return reinterpret_cast<const TorrentInfoRes*>(
               &_TorrentInfoRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TorrentInfoRes& a, TorrentInfoRes& b) {
    a.Swap(&b);
  }
  inline void Swap(TorrentInfoRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TorrentInfoRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TorrentInfoRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TorrentInfoRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TorrentInfoRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TorrentInfoRes& from) {
    TorrentInfoRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TorrentInfoRes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.TorrentInfoRes";
  }
  protected:
  explicit TorrentInfoRes(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTiFieldNumber = 1,
  };
  // .prpc.TorrentInfo ti = 1;
  bool has_ti() const;
  void clear_ti() ;
  const ::prpc::TorrentInfo& ti() const;
  PROTOBUF_NODISCARD ::prpc::TorrentInfo* release_ti();
  ::prpc::TorrentInfo* mutable_ti();
  void set_allocated_ti(::prpc::TorrentInfo* value);
  void unsafe_arena_set_allocated_ti(::prpc::TorrentInfo* value);
  ::prpc::TorrentInfo* unsafe_arena_release_ti();

  private:
  const ::prpc::TorrentInfo& _internal_ti() const;
  ::prpc::TorrentInfo* _internal_mutable_ti();

  public:
  // @@protoc_insertion_point(class_scope:prpc.TorrentInfoRes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::prpc::TorrentInfo* ti_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class RemoveTorrentReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.RemoveTorrentReq) */ {
 public:
  inline RemoveTorrentReq() : RemoveTorrentReq(nullptr) {}
  ~RemoveTorrentReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RemoveTorrentReq(::google::protobuf::internal::ConstantInitialized);

  RemoveTorrentReq(const RemoveTorrentReq& from);
  RemoveTorrentReq(RemoveTorrentReq&& from) noexcept
    : RemoveTorrentReq() {
    *this = ::std::move(from);
  }

  inline RemoveTorrentReq& operator=(const RemoveTorrentReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveTorrentReq& operator=(RemoveTorrentReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveTorrentReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveTorrentReq* internal_default_instance() {
    return reinterpret_cast<const RemoveTorrentReq*>(
               &_RemoveTorrentReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(RemoveTorrentReq& a, RemoveTorrentReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveTorrentReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveTorrentReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveTorrentReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveTorrentReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoveTorrentReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RemoveTorrentReq& from) {
    RemoveTorrentReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveTorrentReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.RemoveTorrentReq";
  }
  protected:
  explicit RemoveTorrentReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoHashFieldNumber = 1,
  };
  // .prpc.InfoHash info_hash = 1;
  bool has_info_hash() const;
  void clear_info_hash() ;
  const ::prpc::InfoHash& info_hash() const;
  PROTOBUF_NODISCARD ::prpc::InfoHash* release_info_hash();
  ::prpc::InfoHash* mutable_info_hash();
  void set_allocated_info_hash(::prpc::InfoHash* value);
  void unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value);
  ::prpc::InfoHash* unsafe_arena_release_info_hash();

  private:
  const ::prpc::InfoHash& _internal_info_hash() const;
  ::prpc::InfoHash* _internal_mutable_info_hash();

  public:
  // @@protoc_insertion_point(class_scope:prpc.RemoveTorrentReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::prpc::InfoHash* info_hash_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class RemoveTorrentRes final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:prpc.RemoveTorrentRes) */ {
 public:
  inline RemoveTorrentRes() : RemoveTorrentRes(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RemoveTorrentRes(::google::protobuf::internal::ConstantInitialized);

  RemoveTorrentRes(const RemoveTorrentRes& from);
  RemoveTorrentRes(RemoveTorrentRes&& from) noexcept
    : RemoveTorrentRes() {
    *this = ::std::move(from);
  }

  inline RemoveTorrentRes& operator=(const RemoveTorrentRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveTorrentRes& operator=(RemoveTorrentRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveTorrentRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveTorrentRes* internal_default_instance() {
    return reinterpret_cast<const RemoveTorrentRes*>(
               &_RemoveTorrentRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RemoveTorrentRes& a, RemoveTorrentRes& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveTorrentRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveTorrentRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveTorrentRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveTorrentRes>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RemoveTorrentRes& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RemoveTorrentRes& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.RemoveTorrentRes";
  }
  protected:
  explicit RemoveTorrentRes(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:prpc.RemoveTorrentRes)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class FileProgressReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.FileProgressReq) */ {
 public:
  inline FileProgressReq() : FileProgressReq(nullptr) {}
  ~FileProgressReq() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FileProgressReq(::google::protobuf::internal::ConstantInitialized);

  FileProgressReq(const FileProgressReq& from);
  FileProgressReq(FileProgressReq&& from) noexcept
    : FileProgressReq() {
    *this = ::std::move(from);
  }

  inline FileProgressReq& operator=(const FileProgressReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileProgressReq& operator=(FileProgressReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileProgressReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileProgressReq* internal_default_instance() {
    return reinterpret_cast<const FileProgressReq*>(
               &_FileProgressReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(FileProgressReq& a, FileProgressReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FileProgressReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileProgressReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileProgressReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileProgressReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FileProgressReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FileProgressReq& from) {
    FileProgressReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileProgressReq* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.FileProgressReq";
  }
  protected:
  explicit FileProgressReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoHashFieldNumber = 1,
  };
  // .prpc.InfoHash info_hash = 1;
  bool has_info_hash() const;
  void clear_info_hash() ;
  const ::prpc::InfoHash& info_hash() const;
  PROTOBUF_NODISCARD ::prpc::InfoHash* release_info_hash();
  ::prpc::InfoHash* mutable_info_hash();
  void set_allocated_info_hash(::prpc::InfoHash* value);
  void unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value);
  ::prpc::InfoHash* unsafe_arena_release_info_hash();

  private:
  const ::prpc::InfoHash& _internal_info_hash() const;
  ::prpc::InfoHash* _internal_mutable_info_hash();

  public:
  // @@protoc_insertion_point(class_scope:prpc.FileProgressReq)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::prpc::InfoHash* info_hash_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class FileProgressRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.FileProgressRes) */ {
 public:
  inline FileProgressRes() : FileProgressRes(nullptr) {}
  ~FileProgressRes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FileProgressRes(::google::protobuf::internal::ConstantInitialized);

  FileProgressRes(const FileProgressRes& from);
  FileProgressRes(FileProgressRes&& from) noexcept
    : FileProgressRes() {
    *this = ::std::move(from);
  }

  inline FileProgressRes& operator=(const FileProgressRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileProgressRes& operator=(FileProgressRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileProgressRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileProgressRes* internal_default_instance() {
    return reinterpret_cast<const FileProgressRes*>(
               &_FileProgressRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(FileProgressRes& a, FileProgressRes& b) {
    a.Swap(&b);
  }
  inline void Swap(FileProgressRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileProgressRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileProgressRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileProgressRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FileProgressRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FileProgressRes& from) {
    FileProgressRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileProgressRes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.FileProgressRes";
  }
  protected:
  explicit FileProgressRes(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilesFieldNumber = 2,
    kInfoHashFieldNumber = 1,
  };
  // repeated .prpc.BtFile files = 2;
  int files_size() const;
  private:
  int _internal_files_size() const;

  public:
  void clear_files() ;
  ::prpc::BtFile* mutable_files(int index);
  ::google::protobuf::RepeatedPtrField< ::prpc::BtFile >*
      mutable_files();
  private:
  const ::google::protobuf::RepeatedPtrField<::prpc::BtFile>& _internal_files() const;
  ::google::protobuf::RepeatedPtrField<::prpc::BtFile>* _internal_mutable_files();
  public:
  const ::prpc::BtFile& files(int index) const;
  ::prpc::BtFile* add_files();
  const ::google::protobuf::RepeatedPtrField< ::prpc::BtFile >&
      files() const;
  // .prpc.InfoHash info_hash = 1;
  bool has_info_hash() const;
  void clear_info_hash() ;
  const ::prpc::InfoHash& info_hash() const;
  PROTOBUF_NODISCARD ::prpc::InfoHash* release_info_hash();
  ::prpc::InfoHash* mutable_info_hash();
  void set_allocated_info_hash(::prpc::InfoHash* value);
  void unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value);
  ::prpc::InfoHash* unsafe_arena_release_info_hash();

  private:
  const ::prpc::InfoHash& _internal_info_hash() const;
  ::prpc::InfoHash* _internal_mutable_info_hash();

  public:
  // @@protoc_insertion_point(class_scope:prpc.FileProgressRes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::prpc::BtFile > files_;
    ::prpc::InfoHash* info_hash_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class FileCompletedReq final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:prpc.FileCompletedReq) */ {
 public:
  inline FileCompletedReq() : FileCompletedReq(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FileCompletedReq(::google::protobuf::internal::ConstantInitialized);

  FileCompletedReq(const FileCompletedReq& from);
  FileCompletedReq(FileCompletedReq&& from) noexcept
    : FileCompletedReq() {
    *this = ::std::move(from);
  }

  inline FileCompletedReq& operator=(const FileCompletedReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileCompletedReq& operator=(FileCompletedReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileCompletedReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileCompletedReq* internal_default_instance() {
    return reinterpret_cast<const FileCompletedReq*>(
               &_FileCompletedReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(FileCompletedReq& a, FileCompletedReq& b) {
    a.Swap(&b);
  }
  inline void Swap(FileCompletedReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileCompletedReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileCompletedReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileCompletedReq>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FileCompletedReq& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FileCompletedReq& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.FileCompletedReq";
  }
  protected:
  explicit FileCompletedReq(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:prpc.FileCompletedReq)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_bt_2eproto;
};// -------------------------------------------------------------------

class FileCompletedRes final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:prpc.FileCompletedRes) */ {
 public:
  inline FileCompletedRes() : FileCompletedRes(nullptr) {}
  ~FileCompletedRes() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FileCompletedRes(::google::protobuf::internal::ConstantInitialized);

  FileCompletedRes(const FileCompletedRes& from);
  FileCompletedRes(FileCompletedRes&& from) noexcept
    : FileCompletedRes() {
    *this = ::std::move(from);
  }

  inline FileCompletedRes& operator=(const FileCompletedRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileCompletedRes& operator=(FileCompletedRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileCompletedRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileCompletedRes* internal_default_instance() {
    return reinterpret_cast<const FileCompletedRes*>(
               &_FileCompletedRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(FileCompletedRes& a, FileCompletedRes& b) {
    a.Swap(&b);
  }
  inline void Swap(FileCompletedRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileCompletedRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileCompletedRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileCompletedRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FileCompletedRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FileCompletedRes& from) {
    FileCompletedRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileCompletedRes* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "prpc.FileCompletedRes";
  }
  protected:
  explicit FileCompletedRes(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoHashFieldNumber = 1,
    kFileIndexFieldNumber = 2,
  };
  // .prpc.InfoHash info_hash = 1;
  bool has_info_hash() const;
  void clear_info_hash() ;
  const ::prpc::InfoHash& info_hash() const;
  PROTOBUF_NODISCARD ::prpc::InfoHash* release_info_hash();
  ::prpc::InfoHash* mutable_info_hash();
  void set_allocated_info_hash(::prpc::InfoHash* value);
  void unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value);
  ::prpc::InfoHash* unsafe_arena_release_info_hash();

  private:
  const ::prpc::InfoHash& _internal_info_hash() const;
  ::prpc::InfoHash* _internal_mutable_info_hash();

  public:
  // int32 file_index = 2;
  void clear_file_index() ;
  ::int32_t file_index() const;
  void set_file_index(::int32_t value);

  private:
  ::int32_t _internal_file_index() const;
  void _internal_set_file_index(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:prpc.FileCompletedRes)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::prpc::InfoHash* info_hash_;
    ::int32_t file_index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bt_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// InitedSessionReq

// -------------------------------------------------------------------

// InitedSessionRsp

// bool inited = 1;
inline void InitedSessionRsp::clear_inited() {
  _impl_.inited_ = false;
}
inline bool InitedSessionRsp::inited() const {
  // @@protoc_insertion_point(field_get:prpc.InitedSessionRsp.inited)
  return _internal_inited();
}
inline void InitedSessionRsp::set_inited(bool value) {
  _internal_set_inited(value);
  // @@protoc_insertion_point(field_set:prpc.InitedSessionRsp.inited)
}
inline bool InitedSessionRsp::_internal_inited() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inited_;
}
inline void InitedSessionRsp::_internal_set_inited(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.inited_ = value;
}

// -------------------------------------------------------------------

// InitSessionReq

// string proxy_hostname = 1;
inline void InitSessionReq::clear_proxy_hostname() {
  _impl_.proxy_hostname_.ClearToEmpty();
}
inline const std::string& InitSessionReq::proxy_hostname() const {
  // @@protoc_insertion_point(field_get:prpc.InitSessionReq.proxy_hostname)
  return _internal_proxy_hostname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InitSessionReq::set_proxy_hostname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.proxy_hostname_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prpc.InitSessionReq.proxy_hostname)
}
inline std::string* InitSessionReq::mutable_proxy_hostname() {
  std::string* _s = _internal_mutable_proxy_hostname();
  // @@protoc_insertion_point(field_mutable:prpc.InitSessionReq.proxy_hostname)
  return _s;
}
inline const std::string& InitSessionReq::_internal_proxy_hostname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.proxy_hostname_.Get();
}
inline void InitSessionReq::_internal_set_proxy_hostname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.proxy_hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* InitSessionReq::_internal_mutable_proxy_hostname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.proxy_hostname_.Mutable( GetArenaForAllocation());
}
inline std::string* InitSessionReq::release_proxy_hostname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.InitSessionReq.proxy_hostname)
  return _impl_.proxy_hostname_.Release();
}
inline void InitSessionReq::set_allocated_proxy_hostname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.proxy_hostname_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proxy_hostname_.IsDefault()) {
          _impl_.proxy_hostname_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prpc.InitSessionReq.proxy_hostname)
}

// int32 proxy_port = 2;
inline void InitSessionReq::clear_proxy_port() {
  _impl_.proxy_port_ = 0;
}
inline ::int32_t InitSessionReq::proxy_port() const {
  // @@protoc_insertion_point(field_get:prpc.InitSessionReq.proxy_port)
  return _internal_proxy_port();
}
inline void InitSessionReq::set_proxy_port(::int32_t value) {
  _internal_set_proxy_port(value);
  // @@protoc_insertion_point(field_set:prpc.InitSessionReq.proxy_port)
}
inline ::int32_t InitSessionReq::_internal_proxy_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.proxy_port_;
}
inline void InitSessionReq::_internal_set_proxy_port(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.proxy_port_ = value;
}

// string proxy_type = 3;
inline void InitSessionReq::clear_proxy_type() {
  _impl_.proxy_type_.ClearToEmpty();
}
inline const std::string& InitSessionReq::proxy_type() const {
  // @@protoc_insertion_point(field_get:prpc.InitSessionReq.proxy_type)
  return _internal_proxy_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InitSessionReq::set_proxy_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.proxy_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prpc.InitSessionReq.proxy_type)
}
inline std::string* InitSessionReq::mutable_proxy_type() {
  std::string* _s = _internal_mutable_proxy_type();
  // @@protoc_insertion_point(field_mutable:prpc.InitSessionReq.proxy_type)
  return _s;
}
inline const std::string& InitSessionReq::_internal_proxy_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.proxy_type_.Get();
}
inline void InitSessionReq::_internal_set_proxy_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.proxy_type_.Set(value, GetArenaForAllocation());
}
inline std::string* InitSessionReq::_internal_mutable_proxy_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.proxy_type_.Mutable( GetArenaForAllocation());
}
inline std::string* InitSessionReq::release_proxy_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.InitSessionReq.proxy_type)
  return _impl_.proxy_type_.Release();
}
inline void InitSessionReq::set_allocated_proxy_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.proxy_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.proxy_type_.IsDefault()) {
          _impl_.proxy_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prpc.InitSessionReq.proxy_type)
}

// int32 upload_rate_limit = 4;
inline void InitSessionReq::clear_upload_rate_limit() {
  _impl_.upload_rate_limit_ = 0;
}
inline ::int32_t InitSessionReq::upload_rate_limit() const {
  // @@protoc_insertion_point(field_get:prpc.InitSessionReq.upload_rate_limit)
  return _internal_upload_rate_limit();
}
inline void InitSessionReq::set_upload_rate_limit(::int32_t value) {
  _internal_set_upload_rate_limit(value);
  // @@protoc_insertion_point(field_set:prpc.InitSessionReq.upload_rate_limit)
}
inline ::int32_t InitSessionReq::_internal_upload_rate_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.upload_rate_limit_;
}
inline void InitSessionReq::_internal_set_upload_rate_limit(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.upload_rate_limit_ = value;
}

// int32 download_rate_limit = 5;
inline void InitSessionReq::clear_download_rate_limit() {
  _impl_.download_rate_limit_ = 0;
}
inline ::int32_t InitSessionReq::download_rate_limit() const {
  // @@protoc_insertion_point(field_get:prpc.InitSessionReq.download_rate_limit)
  return _internal_download_rate_limit();
}
inline void InitSessionReq::set_download_rate_limit(::int32_t value) {
  _internal_set_download_rate_limit(value);
  // @@protoc_insertion_point(field_set:prpc.InitSessionReq.download_rate_limit)
}
inline ::int32_t InitSessionReq::_internal_download_rate_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.download_rate_limit_;
}
inline void InitSessionReq::_internal_set_download_rate_limit(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.download_rate_limit_ = value;
}

// int32 hashing_threads = 6;
inline void InitSessionReq::clear_hashing_threads() {
  _impl_.hashing_threads_ = 0;
}
inline ::int32_t InitSessionReq::hashing_threads() const {
  // @@protoc_insertion_point(field_get:prpc.InitSessionReq.hashing_threads)
  return _internal_hashing_threads();
}
inline void InitSessionReq::set_hashing_threads(::int32_t value) {
  _internal_set_hashing_threads(value);
  // @@protoc_insertion_point(field_set:prpc.InitSessionReq.hashing_threads)
}
inline ::int32_t InitSessionReq::_internal_hashing_threads() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hashing_threads_;
}
inline void InitSessionReq::_internal_set_hashing_threads(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hashing_threads_ = value;
}

// bytes resume_data = 7;
inline void InitSessionReq::clear_resume_data() {
  _impl_.resume_data_.ClearToEmpty();
}
inline const std::string& InitSessionReq::resume_data() const {
  // @@protoc_insertion_point(field_get:prpc.InitSessionReq.resume_data)
  return _internal_resume_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InitSessionReq::set_resume_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.resume_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prpc.InitSessionReq.resume_data)
}
inline std::string* InitSessionReq::mutable_resume_data() {
  std::string* _s = _internal_mutable_resume_data();
  // @@protoc_insertion_point(field_mutable:prpc.InitSessionReq.resume_data)
  return _s;
}
inline const std::string& InitSessionReq::_internal_resume_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.resume_data_.Get();
}
inline void InitSessionReq::_internal_set_resume_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.resume_data_.Set(value, GetArenaForAllocation());
}
inline std::string* InitSessionReq::_internal_mutable_resume_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.resume_data_.Mutable( GetArenaForAllocation());
}
inline std::string* InitSessionReq::release_resume_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.InitSessionReq.resume_data)
  return _impl_.resume_data_.Release();
}
inline void InitSessionReq::set_allocated_resume_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resume_data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.resume_data_.IsDefault()) {
          _impl_.resume_data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prpc.InitSessionReq.resume_data)
}

// -------------------------------------------------------------------

// InitSessionRsp

// -------------------------------------------------------------------

// BtFile

// string name = 1;
inline void BtFile::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& BtFile::name() const {
  // @@protoc_insertion_point(field_get:prpc.BtFile.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BtFile::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prpc.BtFile.name)
}
inline std::string* BtFile::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:prpc.BtFile.name)
  return _s;
}
inline const std::string& BtFile::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void BtFile::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* BtFile::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* BtFile::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.BtFile.name)
  return _impl_.name_.Release();
}
inline void BtFile::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prpc.BtFile.name)
}

// int32 index = 2;
inline void BtFile::clear_index() {
  _impl_.index_ = 0;
}
inline ::int32_t BtFile::index() const {
  // @@protoc_insertion_point(field_get:prpc.BtFile.index)
  return _internal_index();
}
inline void BtFile::set_index(::int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:prpc.BtFile.index)
}
inline ::int32_t BtFile::_internal_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.index_;
}
inline void BtFile::_internal_set_index(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.index_ = value;
}

// .prpc.BtFile.State st = 3;
inline void BtFile::clear_st() {
  _impl_.st_ = 0;
}
inline ::prpc::BtFile_State BtFile::st() const {
  // @@protoc_insertion_point(field_get:prpc.BtFile.st)
  return _internal_st();
}
inline void BtFile::set_st(::prpc::BtFile_State value) {
  _internal_set_st(value);
  // @@protoc_insertion_point(field_set:prpc.BtFile.st)
}
inline ::prpc::BtFile_State BtFile::_internal_st() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::prpc::BtFile_State>(_impl_.st_);
}
inline void BtFile::_internal_set_st(::prpc::BtFile_State value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.st_ = value;
}

// int64 total_size = 4;
inline void BtFile::clear_total_size() {
  _impl_.total_size_ = ::int64_t{0};
}
inline ::int64_t BtFile::total_size() const {
  // @@protoc_insertion_point(field_get:prpc.BtFile.total_size)
  return _internal_total_size();
}
inline void BtFile::set_total_size(::int64_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:prpc.BtFile.total_size)
}
inline ::int64_t BtFile::_internal_total_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_size_;
}
inline void BtFile::_internal_set_total_size(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_size_ = value;
}

// int64 downloaded = 5;
inline void BtFile::clear_downloaded() {
  _impl_.downloaded_ = ::int64_t{0};
}
inline ::int64_t BtFile::downloaded() const {
  // @@protoc_insertion_point(field_get:prpc.BtFile.downloaded)
  return _internal_downloaded();
}
inline void BtFile::set_downloaded(::int64_t value) {
  _internal_set_downloaded(value);
  // @@protoc_insertion_point(field_set:prpc.BtFile.downloaded)
}
inline ::int64_t BtFile::_internal_downloaded() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.downloaded_;
}
inline void BtFile::_internal_set_downloaded(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.downloaded_ = value;
}

// -------------------------------------------------------------------

// TorrentInfo

// .prpc.InfoHash info_hash = 1;
inline bool TorrentInfo::has_info_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_hash_ != nullptr);
  return value;
}
inline void TorrentInfo::clear_info_hash() {
  if (_impl_.info_hash_ != nullptr) _impl_.info_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::prpc::InfoHash& TorrentInfo::_internal_info_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::prpc::InfoHash* p = _impl_.info_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::prpc::InfoHash&>(::prpc::_InfoHash_default_instance_);
}
inline const ::prpc::InfoHash& TorrentInfo::info_hash() const {
  // @@protoc_insertion_point(field_get:prpc.TorrentInfo.info_hash)
  return _internal_info_hash();
}
inline void TorrentInfo::unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_hash_);
  }
  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prpc.TorrentInfo.info_hash)
}
inline ::prpc::InfoHash* TorrentInfo::release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* released = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::prpc::InfoHash* TorrentInfo::unsafe_arena_release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.TorrentInfo.info_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* temp = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
  return temp;
}
inline ::prpc::InfoHash* TorrentInfo::_internal_mutable_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::prpc::InfoHash>(GetArenaForAllocation());
    _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(p);
  }
  return _impl_.info_hash_;
}
inline ::prpc::InfoHash* TorrentInfo::mutable_info_hash() {
  ::prpc::InfoHash* _msg = _internal_mutable_info_hash();
  // @@protoc_insertion_point(field_mutable:prpc.TorrentInfo.info_hash)
  return _msg;
}
inline void TorrentInfo::set_allocated_info_hash(::prpc::InfoHash* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::prpc::InfoHash*>(_impl_.info_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::prpc::InfoHash*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  // @@protoc_insertion_point(field_set_allocated:prpc.TorrentInfo.info_hash)
}

// string name = 2;
inline void TorrentInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TorrentInfo::name() const {
  // @@protoc_insertion_point(field_get:prpc.TorrentInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TorrentInfo::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prpc.TorrentInfo.name)
}
inline std::string* TorrentInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:prpc.TorrentInfo.name)
  return _s;
}
inline const std::string& TorrentInfo::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void TorrentInfo::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TorrentInfo::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* TorrentInfo::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.TorrentInfo.name)
  return _impl_.name_.Release();
}
inline void TorrentInfo::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prpc.TorrentInfo.name)
}

// string save_path = 3;
inline void TorrentInfo::clear_save_path() {
  _impl_.save_path_.ClearToEmpty();
}
inline const std::string& TorrentInfo::save_path() const {
  // @@protoc_insertion_point(field_get:prpc.TorrentInfo.save_path)
  return _internal_save_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TorrentInfo::set_save_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.save_path_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prpc.TorrentInfo.save_path)
}
inline std::string* TorrentInfo::mutable_save_path() {
  std::string* _s = _internal_mutable_save_path();
  // @@protoc_insertion_point(field_mutable:prpc.TorrentInfo.save_path)
  return _s;
}
inline const std::string& TorrentInfo::_internal_save_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.save_path_.Get();
}
inline void TorrentInfo::_internal_set_save_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.save_path_.Set(value, GetArenaForAllocation());
}
inline std::string* TorrentInfo::_internal_mutable_save_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.save_path_.Mutable( GetArenaForAllocation());
}
inline std::string* TorrentInfo::release_save_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.TorrentInfo.save_path)
  return _impl_.save_path_.Release();
}
inline void TorrentInfo::set_allocated_save_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.save_path_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.save_path_.IsDefault()) {
          _impl_.save_path_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prpc.TorrentInfo.save_path)
}

// repeated .prpc.BtFile files = 4;
inline int TorrentInfo::_internal_files_size() const {
  return _internal_files().size();
}
inline int TorrentInfo::files_size() const {
  return _internal_files_size();
}
inline void TorrentInfo::clear_files() {
  _internal_mutable_files()->Clear();
}
inline ::prpc::BtFile* TorrentInfo::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:prpc.TorrentInfo.files)
  return _internal_mutable_files()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::prpc::BtFile >*
TorrentInfo::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:prpc.TorrentInfo.files)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_files();
}
inline const ::prpc::BtFile& TorrentInfo::files(int index) const {
  // @@protoc_insertion_point(field_get:prpc.TorrentInfo.files)
    return _internal_files().Get(index);
}
inline ::prpc::BtFile* TorrentInfo::add_files() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::prpc::BtFile* _add = _internal_mutable_files()->Add();
  // @@protoc_insertion_point(field_add:prpc.TorrentInfo.files)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::prpc::BtFile >&
TorrentInfo::files() const {
  // @@protoc_insertion_point(field_list:prpc.TorrentInfo.files)
  return _internal_files();
}
inline const ::google::protobuf::RepeatedPtrField<::prpc::BtFile>&
TorrentInfo::_internal_files() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.files_;
}
inline ::google::protobuf::RepeatedPtrField<::prpc::BtFile>*
TorrentInfo::_internal_mutable_files() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.files_;
}

// int64 total_size = 5;
inline void TorrentInfo::clear_total_size() {
  _impl_.total_size_ = ::int64_t{0};
}
inline ::int64_t TorrentInfo::total_size() const {
  // @@protoc_insertion_point(field_get:prpc.TorrentInfo.total_size)
  return _internal_total_size();
}
inline void TorrentInfo::set_total_size(::int64_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:prpc.TorrentInfo.total_size)
}
inline ::int64_t TorrentInfo::_internal_total_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_size_;
}
inline void TorrentInfo::_internal_set_total_size(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_size_ = value;
}

// int32 piece_length = 6;
inline void TorrentInfo::clear_piece_length() {
  _impl_.piece_length_ = 0;
}
inline ::int32_t TorrentInfo::piece_length() const {
  // @@protoc_insertion_point(field_get:prpc.TorrentInfo.piece_length)
  return _internal_piece_length();
}
inline void TorrentInfo::set_piece_length(::int32_t value) {
  _internal_set_piece_length(value);
  // @@protoc_insertion_point(field_set:prpc.TorrentInfo.piece_length)
}
inline ::int32_t TorrentInfo::_internal_piece_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.piece_length_;
}
inline void TorrentInfo::_internal_set_piece_length(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.piece_length_ = value;
}

// int32 num_pieces = 7;
inline void TorrentInfo::clear_num_pieces() {
  _impl_.num_pieces_ = 0;
}
inline ::int32_t TorrentInfo::num_pieces() const {
  // @@protoc_insertion_point(field_get:prpc.TorrentInfo.num_pieces)
  return _internal_num_pieces();
}
inline void TorrentInfo::set_num_pieces(::int32_t value) {
  _internal_set_num_pieces(value);
  // @@protoc_insertion_point(field_set:prpc.TorrentInfo.num_pieces)
}
inline ::int32_t TorrentInfo::_internal_num_pieces() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_pieces_;
}
inline void TorrentInfo::_internal_set_num_pieces(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_pieces_ = value;
}

// -------------------------------------------------------------------

// TorrentStatus

// .prpc.InfoHash info_hash = 1;
inline bool TorrentStatus::has_info_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_hash_ != nullptr);
  return value;
}
inline void TorrentStatus::clear_info_hash() {
  if (_impl_.info_hash_ != nullptr) _impl_.info_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::prpc::InfoHash& TorrentStatus::_internal_info_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::prpc::InfoHash* p = _impl_.info_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::prpc::InfoHash&>(::prpc::_InfoHash_default_instance_);
}
inline const ::prpc::InfoHash& TorrentStatus::info_hash() const {
  // @@protoc_insertion_point(field_get:prpc.TorrentStatus.info_hash)
  return _internal_info_hash();
}
inline void TorrentStatus::unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_hash_);
  }
  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prpc.TorrentStatus.info_hash)
}
inline ::prpc::InfoHash* TorrentStatus::release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* released = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::prpc::InfoHash* TorrentStatus::unsafe_arena_release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.TorrentStatus.info_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* temp = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
  return temp;
}
inline ::prpc::InfoHash* TorrentStatus::_internal_mutable_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::prpc::InfoHash>(GetArenaForAllocation());
    _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(p);
  }
  return _impl_.info_hash_;
}
inline ::prpc::InfoHash* TorrentStatus::mutable_info_hash() {
  ::prpc::InfoHash* _msg = _internal_mutable_info_hash();
  // @@protoc_insertion_point(field_mutable:prpc.TorrentStatus.info_hash)
  return _msg;
}
inline void TorrentStatus::set_allocated_info_hash(::prpc::InfoHash* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::prpc::InfoHash*>(_impl_.info_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::prpc::InfoHash*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  // @@protoc_insertion_point(field_set_allocated:prpc.TorrentStatus.info_hash)
}

// string name = 2;
inline void TorrentStatus::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& TorrentStatus::name() const {
  // @@protoc_insertion_point(field_get:prpc.TorrentStatus.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TorrentStatus::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prpc.TorrentStatus.name)
}
inline std::string* TorrentStatus::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:prpc.TorrentStatus.name)
  return _s;
}
inline const std::string& TorrentStatus::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void TorrentStatus::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* TorrentStatus::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* TorrentStatus::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.TorrentStatus.name)
  return _impl_.name_.Release();
}
inline void TorrentStatus::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prpc.TorrentStatus.name)
}

// int32 download_payload_rate = 3;
inline void TorrentStatus::clear_download_payload_rate() {
  _impl_.download_payload_rate_ = 0;
}
inline ::int32_t TorrentStatus::download_payload_rate() const {
  // @@protoc_insertion_point(field_get:prpc.TorrentStatus.download_payload_rate)
  return _internal_download_payload_rate();
}
inline void TorrentStatus::set_download_payload_rate(::int32_t value) {
  _internal_set_download_payload_rate(value);
  // @@protoc_insertion_point(field_set:prpc.TorrentStatus.download_payload_rate)
}
inline ::int32_t TorrentStatus::_internal_download_payload_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.download_payload_rate_;
}
inline void TorrentStatus::_internal_set_download_payload_rate(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.download_payload_rate_ = value;
}

// int64 total_done = 4;
inline void TorrentStatus::clear_total_done() {
  _impl_.total_done_ = ::int64_t{0};
}
inline ::int64_t TorrentStatus::total_done() const {
  // @@protoc_insertion_point(field_get:prpc.TorrentStatus.total_done)
  return _internal_total_done();
}
inline void TorrentStatus::set_total_done(::int64_t value) {
  _internal_set_total_done(value);
  // @@protoc_insertion_point(field_set:prpc.TorrentStatus.total_done)
}
inline ::int64_t TorrentStatus::_internal_total_done() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_done_;
}
inline void TorrentStatus::_internal_set_total_done(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_done_ = value;
}

// int64 total = 5;
inline void TorrentStatus::clear_total() {
  _impl_.total_ = ::int64_t{0};
}
inline ::int64_t TorrentStatus::total() const {
  // @@protoc_insertion_point(field_get:prpc.TorrentStatus.total)
  return _internal_total();
}
inline void TorrentStatus::set_total(::int64_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:prpc.TorrentStatus.total)
}
inline ::int64_t TorrentStatus::_internal_total() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_;
}
inline void TorrentStatus::_internal_set_total(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_ = value;
}

// float progress = 6;
inline void TorrentStatus::clear_progress() {
  _impl_.progress_ = 0;
}
inline float TorrentStatus::progress() const {
  // @@protoc_insertion_point(field_get:prpc.TorrentStatus.progress)
  return _internal_progress();
}
inline void TorrentStatus::set_progress(float value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:prpc.TorrentStatus.progress)
}
inline float TorrentStatus::_internal_progress() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.progress_;
}
inline void TorrentStatus::_internal_set_progress(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.progress_ = value;
}

// int32 num_peers = 7;
inline void TorrentStatus::clear_num_peers() {
  _impl_.num_peers_ = 0;
}
inline ::int32_t TorrentStatus::num_peers() const {
  // @@protoc_insertion_point(field_get:prpc.TorrentStatus.num_peers)
  return _internal_num_peers();
}
inline void TorrentStatus::set_num_peers(::int32_t value) {
  _internal_set_num_peers(value);
  // @@protoc_insertion_point(field_set:prpc.TorrentStatus.num_peers)
}
inline ::int32_t TorrentStatus::_internal_num_peers() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_peers_;
}
inline void TorrentStatus::_internal_set_num_peers(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_peers_ = value;
}

// .prpc.BtStateEnum state = 8;
inline void TorrentStatus::clear_state() {
  _impl_.state_ = 0;
}
inline ::prpc::BtStateEnum TorrentStatus::state() const {
  // @@protoc_insertion_point(field_get:prpc.TorrentStatus.state)
  return _internal_state();
}
inline void TorrentStatus::set_state(::prpc::BtStateEnum value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:prpc.TorrentStatus.state)
}
inline ::prpc::BtStateEnum TorrentStatus::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::prpc::BtStateEnum>(_impl_.state_);
}
inline void TorrentStatus::_internal_set_state(::prpc::BtStateEnum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// DownloadRequest

// .prpc.DownloadRequest.ReqType type = 1;
inline void DownloadRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::prpc::DownloadRequest_ReqType DownloadRequest::type() const {
  // @@protoc_insertion_point(field_get:prpc.DownloadRequest.type)
  return _internal_type();
}
inline void DownloadRequest::set_type(::prpc::DownloadRequest_ReqType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:prpc.DownloadRequest.type)
}
inline ::prpc::DownloadRequest_ReqType DownloadRequest::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::prpc::DownloadRequest_ReqType>(_impl_.type_);
}
inline void DownloadRequest::_internal_set_type(::prpc::DownloadRequest_ReqType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// bytes content = 2;
inline void DownloadRequest::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& DownloadRequest::content() const {
  // @@protoc_insertion_point(field_get:prpc.DownloadRequest.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DownloadRequest::set_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prpc.DownloadRequest.content)
}
inline std::string* DownloadRequest::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:prpc.DownloadRequest.content)
  return _s;
}
inline const std::string& DownloadRequest::_internal_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_.Get();
}
inline void DownloadRequest::_internal_set_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadRequest::_internal_mutable_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.content_.Mutable( GetArenaForAllocation());
}
inline std::string* DownloadRequest::release_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.DownloadRequest.content)
  return _impl_.content_.Release();
}
inline void DownloadRequest::set_allocated_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prpc.DownloadRequest.content)
}

// string save_path = 3;
inline void DownloadRequest::clear_save_path() {
  _impl_.save_path_.ClearToEmpty();
}
inline const std::string& DownloadRequest::save_path() const {
  // @@protoc_insertion_point(field_get:prpc.DownloadRequest.save_path)
  return _internal_save_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DownloadRequest::set_save_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.save_path_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prpc.DownloadRequest.save_path)
}
inline std::string* DownloadRequest::mutable_save_path() {
  std::string* _s = _internal_mutable_save_path();
  // @@protoc_insertion_point(field_mutable:prpc.DownloadRequest.save_path)
  return _s;
}
inline const std::string& DownloadRequest::_internal_save_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.save_path_.Get();
}
inline void DownloadRequest::_internal_set_save_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.save_path_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadRequest::_internal_mutable_save_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.save_path_.Mutable( GetArenaForAllocation());
}
inline std::string* DownloadRequest::release_save_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.DownloadRequest.save_path)
  return _impl_.save_path_.Release();
}
inline void DownloadRequest::set_allocated_save_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.save_path_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.save_path_.IsDefault()) {
          _impl_.save_path_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prpc.DownloadRequest.save_path)
}

// -------------------------------------------------------------------

// InfoHash

// int32 version = 1;
inline void InfoHash::clear_version() {
  _impl_.version_ = 0;
}
inline ::int32_t InfoHash::version() const {
  // @@protoc_insertion_point(field_get:prpc.InfoHash.version)
  return _internal_version();
}
inline void InfoHash::set_version(::int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:prpc.InfoHash.version)
}
inline ::int32_t InfoHash::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_;
}
inline void InfoHash::_internal_set_version(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.version_ = value;
}

// bytes hash = 2;
inline void InfoHash::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& InfoHash::hash() const {
  // @@protoc_insertion_point(field_get:prpc.InfoHash.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InfoHash::set_hash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prpc.InfoHash.hash)
}
inline std::string* InfoHash::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:prpc.InfoHash.hash)
  return _s;
}
inline const std::string& InfoHash::_internal_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hash_.Get();
}
inline void InfoHash::_internal_set_hash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* InfoHash::_internal_mutable_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.hash_.Mutable( GetArenaForAllocation());
}
inline std::string* InfoHash::release_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.InfoHash.hash)
  return _impl_.hash_.Release();
}
inline void InfoHash::set_allocated_hash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hash_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.hash_.IsDefault()) {
          _impl_.hash_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prpc.InfoHash.hash)
}

// -------------------------------------------------------------------

// DownloadRespone

// .prpc.InfoHash info_hash = 1;
inline bool DownloadRespone::has_info_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_hash_ != nullptr);
  return value;
}
inline void DownloadRespone::clear_info_hash() {
  if (_impl_.info_hash_ != nullptr) _impl_.info_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::prpc::InfoHash& DownloadRespone::_internal_info_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::prpc::InfoHash* p = _impl_.info_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::prpc::InfoHash&>(::prpc::_InfoHash_default_instance_);
}
inline const ::prpc::InfoHash& DownloadRespone::info_hash() const {
  // @@protoc_insertion_point(field_get:prpc.DownloadRespone.info_hash)
  return _internal_info_hash();
}
inline void DownloadRespone::unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_hash_);
  }
  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prpc.DownloadRespone.info_hash)
}
inline ::prpc::InfoHash* DownloadRespone::release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* released = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::prpc::InfoHash* DownloadRespone::unsafe_arena_release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.DownloadRespone.info_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* temp = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
  return temp;
}
inline ::prpc::InfoHash* DownloadRespone::_internal_mutable_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::prpc::InfoHash>(GetArenaForAllocation());
    _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(p);
  }
  return _impl_.info_hash_;
}
inline ::prpc::InfoHash* DownloadRespone::mutable_info_hash() {
  ::prpc::InfoHash* _msg = _internal_mutable_info_hash();
  // @@protoc_insertion_point(field_mutable:prpc.DownloadRespone.info_hash)
  return _msg;
}
inline void DownloadRespone::set_allocated_info_hash(::prpc::InfoHash* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::prpc::InfoHash*>(_impl_.info_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::prpc::InfoHash*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  // @@protoc_insertion_point(field_set_allocated:prpc.DownloadRespone.info_hash)
}

// -------------------------------------------------------------------

// GetMagnetUriReq

// .prpc.GetMagnetUriReq.ReqType type = 1;
inline void GetMagnetUriReq::clear_type() {
  _impl_.type_ = 0;
}
inline ::prpc::GetMagnetUriReq_ReqType GetMagnetUriReq::type() const {
  // @@protoc_insertion_point(field_get:prpc.GetMagnetUriReq.type)
  return _internal_type();
}
inline void GetMagnetUriReq::set_type(::prpc::GetMagnetUriReq_ReqType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:prpc.GetMagnetUriReq.type)
}
inline ::prpc::GetMagnetUriReq_ReqType GetMagnetUriReq::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::prpc::GetMagnetUriReq_ReqType>(_impl_.type_);
}
inline void GetMagnetUriReq::_internal_set_type(::prpc::GetMagnetUriReq_ReqType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// bytes content = 2;
inline void GetMagnetUriReq::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& GetMagnetUriReq::content() const {
  // @@protoc_insertion_point(field_get:prpc.GetMagnetUriReq.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetMagnetUriReq::set_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prpc.GetMagnetUriReq.content)
}
inline std::string* GetMagnetUriReq::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:prpc.GetMagnetUriReq.content)
  return _s;
}
inline const std::string& GetMagnetUriReq::_internal_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_.Get();
}
inline void GetMagnetUriReq::_internal_set_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* GetMagnetUriReq::_internal_mutable_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.content_.Mutable( GetArenaForAllocation());
}
inline std::string* GetMagnetUriReq::release_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.GetMagnetUriReq.content)
  return _impl_.content_.Release();
}
inline void GetMagnetUriReq::set_allocated_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prpc.GetMagnetUriReq.content)
}

// .prpc.InfoHash info_hash = 3;
inline bool GetMagnetUriReq::has_info_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_hash_ != nullptr);
  return value;
}
inline void GetMagnetUriReq::clear_info_hash() {
  if (_impl_.info_hash_ != nullptr) _impl_.info_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::prpc::InfoHash& GetMagnetUriReq::_internal_info_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::prpc::InfoHash* p = _impl_.info_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::prpc::InfoHash&>(::prpc::_InfoHash_default_instance_);
}
inline const ::prpc::InfoHash& GetMagnetUriReq::info_hash() const {
  // @@protoc_insertion_point(field_get:prpc.GetMagnetUriReq.info_hash)
  return _internal_info_hash();
}
inline void GetMagnetUriReq::unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_hash_);
  }
  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prpc.GetMagnetUriReq.info_hash)
}
inline ::prpc::InfoHash* GetMagnetUriReq::release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* released = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::prpc::InfoHash* GetMagnetUriReq::unsafe_arena_release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.GetMagnetUriReq.info_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* temp = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
  return temp;
}
inline ::prpc::InfoHash* GetMagnetUriReq::_internal_mutable_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::prpc::InfoHash>(GetArenaForAllocation());
    _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(p);
  }
  return _impl_.info_hash_;
}
inline ::prpc::InfoHash* GetMagnetUriReq::mutable_info_hash() {
  ::prpc::InfoHash* _msg = _internal_mutable_info_hash();
  // @@protoc_insertion_point(field_mutable:prpc.GetMagnetUriReq.info_hash)
  return _msg;
}
inline void GetMagnetUriReq::set_allocated_info_hash(::prpc::InfoHash* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::prpc::InfoHash*>(_impl_.info_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::prpc::InfoHash*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  // @@protoc_insertion_point(field_set_allocated:prpc.GetMagnetUriReq.info_hash)
}

// -------------------------------------------------------------------

// GetMagnetUriRsp

// .prpc.InfoHash info_hash = 1;
inline bool GetMagnetUriRsp::has_info_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_hash_ != nullptr);
  return value;
}
inline void GetMagnetUriRsp::clear_info_hash() {
  if (_impl_.info_hash_ != nullptr) _impl_.info_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::prpc::InfoHash& GetMagnetUriRsp::_internal_info_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::prpc::InfoHash* p = _impl_.info_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::prpc::InfoHash&>(::prpc::_InfoHash_default_instance_);
}
inline const ::prpc::InfoHash& GetMagnetUriRsp::info_hash() const {
  // @@protoc_insertion_point(field_get:prpc.GetMagnetUriRsp.info_hash)
  return _internal_info_hash();
}
inline void GetMagnetUriRsp::unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_hash_);
  }
  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prpc.GetMagnetUriRsp.info_hash)
}
inline ::prpc::InfoHash* GetMagnetUriRsp::release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* released = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::prpc::InfoHash* GetMagnetUriRsp::unsafe_arena_release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.GetMagnetUriRsp.info_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* temp = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
  return temp;
}
inline ::prpc::InfoHash* GetMagnetUriRsp::_internal_mutable_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::prpc::InfoHash>(GetArenaForAllocation());
    _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(p);
  }
  return _impl_.info_hash_;
}
inline ::prpc::InfoHash* GetMagnetUriRsp::mutable_info_hash() {
  ::prpc::InfoHash* _msg = _internal_mutable_info_hash();
  // @@protoc_insertion_point(field_mutable:prpc.GetMagnetUriRsp.info_hash)
  return _msg;
}
inline void GetMagnetUriRsp::set_allocated_info_hash(::prpc::InfoHash* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::prpc::InfoHash*>(_impl_.info_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::prpc::InfoHash*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  // @@protoc_insertion_point(field_set_allocated:prpc.GetMagnetUriRsp.info_hash)
}

// string magnet_uri = 2;
inline void GetMagnetUriRsp::clear_magnet_uri() {
  _impl_.magnet_uri_.ClearToEmpty();
}
inline const std::string& GetMagnetUriRsp::magnet_uri() const {
  // @@protoc_insertion_point(field_get:prpc.GetMagnetUriRsp.magnet_uri)
  return _internal_magnet_uri();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetMagnetUriRsp::set_magnet_uri(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.magnet_uri_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prpc.GetMagnetUriRsp.magnet_uri)
}
inline std::string* GetMagnetUriRsp::mutable_magnet_uri() {
  std::string* _s = _internal_mutable_magnet_uri();
  // @@protoc_insertion_point(field_mutable:prpc.GetMagnetUriRsp.magnet_uri)
  return _s;
}
inline const std::string& GetMagnetUriRsp::_internal_magnet_uri() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.magnet_uri_.Get();
}
inline void GetMagnetUriRsp::_internal_set_magnet_uri(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.magnet_uri_.Set(value, GetArenaForAllocation());
}
inline std::string* GetMagnetUriRsp::_internal_mutable_magnet_uri() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.magnet_uri_.Mutable( GetArenaForAllocation());
}
inline std::string* GetMagnetUriRsp::release_magnet_uri() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.GetMagnetUriRsp.magnet_uri)
  return _impl_.magnet_uri_.Release();
}
inline void GetMagnetUriRsp::set_allocated_magnet_uri(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.magnet_uri_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.magnet_uri_.IsDefault()) {
          _impl_.magnet_uri_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prpc.GetMagnetUriRsp.magnet_uri)
}

// -------------------------------------------------------------------

// GetResumeDataReq

// .prpc.InfoHash info_hash = 1;
inline bool GetResumeDataReq::has_info_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_hash_ != nullptr);
  return value;
}
inline void GetResumeDataReq::clear_info_hash() {
  if (_impl_.info_hash_ != nullptr) _impl_.info_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::prpc::InfoHash& GetResumeDataReq::_internal_info_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::prpc::InfoHash* p = _impl_.info_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::prpc::InfoHash&>(::prpc::_InfoHash_default_instance_);
}
inline const ::prpc::InfoHash& GetResumeDataReq::info_hash() const {
  // @@protoc_insertion_point(field_get:prpc.GetResumeDataReq.info_hash)
  return _internal_info_hash();
}
inline void GetResumeDataReq::unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_hash_);
  }
  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prpc.GetResumeDataReq.info_hash)
}
inline ::prpc::InfoHash* GetResumeDataReq::release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* released = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::prpc::InfoHash* GetResumeDataReq::unsafe_arena_release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.GetResumeDataReq.info_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* temp = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
  return temp;
}
inline ::prpc::InfoHash* GetResumeDataReq::_internal_mutable_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::prpc::InfoHash>(GetArenaForAllocation());
    _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(p);
  }
  return _impl_.info_hash_;
}
inline ::prpc::InfoHash* GetResumeDataReq::mutable_info_hash() {
  ::prpc::InfoHash* _msg = _internal_mutable_info_hash();
  // @@protoc_insertion_point(field_mutable:prpc.GetResumeDataReq.info_hash)
  return _msg;
}
inline void GetResumeDataReq::set_allocated_info_hash(::prpc::InfoHash* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::prpc::InfoHash*>(_impl_.info_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::prpc::InfoHash*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  // @@protoc_insertion_point(field_set_allocated:prpc.GetResumeDataReq.info_hash)
}

// -------------------------------------------------------------------

// GetResumeDataRsp

// bytes resume_data = 1;
inline void GetResumeDataRsp::clear_resume_data() {
  _impl_.resume_data_.ClearToEmpty();
}
inline const std::string& GetResumeDataRsp::resume_data() const {
  // @@protoc_insertion_point(field_get:prpc.GetResumeDataRsp.resume_data)
  return _internal_resume_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetResumeDataRsp::set_resume_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.resume_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prpc.GetResumeDataRsp.resume_data)
}
inline std::string* GetResumeDataRsp::mutable_resume_data() {
  std::string* _s = _internal_mutable_resume_data();
  // @@protoc_insertion_point(field_mutable:prpc.GetResumeDataRsp.resume_data)
  return _s;
}
inline const std::string& GetResumeDataRsp::_internal_resume_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.resume_data_.Get();
}
inline void GetResumeDataRsp::_internal_set_resume_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.resume_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetResumeDataRsp::_internal_mutable_resume_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.resume_data_.Mutable( GetArenaForAllocation());
}
inline std::string* GetResumeDataRsp::release_resume_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.GetResumeDataRsp.resume_data)
  return _impl_.resume_data_.Release();
}
inline void GetResumeDataRsp::set_allocated_resume_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resume_data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.resume_data_.IsDefault()) {
          _impl_.resume_data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prpc.GetResumeDataRsp.resume_data)
}

// -------------------------------------------------------------------

// GetTorrentInfoReq

// .prpc.InfoHash info_hash = 1;
inline bool GetTorrentInfoReq::has_info_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_hash_ != nullptr);
  return value;
}
inline void GetTorrentInfoReq::clear_info_hash() {
  if (_impl_.info_hash_ != nullptr) _impl_.info_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::prpc::InfoHash& GetTorrentInfoReq::_internal_info_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::prpc::InfoHash* p = _impl_.info_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::prpc::InfoHash&>(::prpc::_InfoHash_default_instance_);
}
inline const ::prpc::InfoHash& GetTorrentInfoReq::info_hash() const {
  // @@protoc_insertion_point(field_get:prpc.GetTorrentInfoReq.info_hash)
  return _internal_info_hash();
}
inline void GetTorrentInfoReq::unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_hash_);
  }
  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prpc.GetTorrentInfoReq.info_hash)
}
inline ::prpc::InfoHash* GetTorrentInfoReq::release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* released = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::prpc::InfoHash* GetTorrentInfoReq::unsafe_arena_release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.GetTorrentInfoReq.info_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* temp = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
  return temp;
}
inline ::prpc::InfoHash* GetTorrentInfoReq::_internal_mutable_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::prpc::InfoHash>(GetArenaForAllocation());
    _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(p);
  }
  return _impl_.info_hash_;
}
inline ::prpc::InfoHash* GetTorrentInfoReq::mutable_info_hash() {
  ::prpc::InfoHash* _msg = _internal_mutable_info_hash();
  // @@protoc_insertion_point(field_mutable:prpc.GetTorrentInfoReq.info_hash)
  return _msg;
}
inline void GetTorrentInfoReq::set_allocated_info_hash(::prpc::InfoHash* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::prpc::InfoHash*>(_impl_.info_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::prpc::InfoHash*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  // @@protoc_insertion_point(field_set_allocated:prpc.GetTorrentInfoReq.info_hash)
}

// -------------------------------------------------------------------

// GetTorrentInfoRsp

// .prpc.TorrentInfo torrent_info = 1;
inline bool GetTorrentInfoRsp::has_torrent_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.torrent_info_ != nullptr);
  return value;
}
inline void GetTorrentInfoRsp::clear_torrent_info() {
  if (_impl_.torrent_info_ != nullptr) _impl_.torrent_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::prpc::TorrentInfo& GetTorrentInfoRsp::_internal_torrent_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::prpc::TorrentInfo* p = _impl_.torrent_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::prpc::TorrentInfo&>(::prpc::_TorrentInfo_default_instance_);
}
inline const ::prpc::TorrentInfo& GetTorrentInfoRsp::torrent_info() const {
  // @@protoc_insertion_point(field_get:prpc.GetTorrentInfoRsp.torrent_info)
  return _internal_torrent_info();
}
inline void GetTorrentInfoRsp::unsafe_arena_set_allocated_torrent_info(::prpc::TorrentInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.torrent_info_);
  }
  _impl_.torrent_info_ = reinterpret_cast<::prpc::TorrentInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prpc.GetTorrentInfoRsp.torrent_info)
}
inline ::prpc::TorrentInfo* GetTorrentInfoRsp::release_torrent_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::TorrentInfo* released = _impl_.torrent_info_;
  _impl_.torrent_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::prpc::TorrentInfo* GetTorrentInfoRsp::unsafe_arena_release_torrent_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.GetTorrentInfoRsp.torrent_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::TorrentInfo* temp = _impl_.torrent_info_;
  _impl_.torrent_info_ = nullptr;
  return temp;
}
inline ::prpc::TorrentInfo* GetTorrentInfoRsp::_internal_mutable_torrent_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.torrent_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::prpc::TorrentInfo>(GetArenaForAllocation());
    _impl_.torrent_info_ = reinterpret_cast<::prpc::TorrentInfo*>(p);
  }
  return _impl_.torrent_info_;
}
inline ::prpc::TorrentInfo* GetTorrentInfoRsp::mutable_torrent_info() {
  ::prpc::TorrentInfo* _msg = _internal_mutable_torrent_info();
  // @@protoc_insertion_point(field_mutable:prpc.GetTorrentInfoRsp.torrent_info)
  return _msg;
}
inline void GetTorrentInfoRsp::set_allocated_torrent_info(::prpc::TorrentInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::prpc::TorrentInfo*>(_impl_.torrent_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::prpc::TorrentInfo*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.torrent_info_ = reinterpret_cast<::prpc::TorrentInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:prpc.GetTorrentInfoRsp.torrent_info)
}

// -------------------------------------------------------------------

// GetSessionParamsReq

// -------------------------------------------------------------------

// GetSessionParamsRsp

// bytes resume_data = 1;
inline void GetSessionParamsRsp::clear_resume_data() {
  _impl_.resume_data_.ClearToEmpty();
}
inline const std::string& GetSessionParamsRsp::resume_data() const {
  // @@protoc_insertion_point(field_get:prpc.GetSessionParamsRsp.resume_data)
  return _internal_resume_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetSessionParamsRsp::set_resume_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.resume_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:prpc.GetSessionParamsRsp.resume_data)
}
inline std::string* GetSessionParamsRsp::mutable_resume_data() {
  std::string* _s = _internal_mutable_resume_data();
  // @@protoc_insertion_point(field_mutable:prpc.GetSessionParamsRsp.resume_data)
  return _s;
}
inline const std::string& GetSessionParamsRsp::_internal_resume_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.resume_data_.Get();
}
inline void GetSessionParamsRsp::_internal_set_resume_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.resume_data_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSessionParamsRsp::_internal_mutable_resume_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.resume_data_.Mutable( GetArenaForAllocation());
}
inline std::string* GetSessionParamsRsp::release_resume_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.GetSessionParamsRsp.resume_data)
  return _impl_.resume_data_.Release();
}
inline void GetSessionParamsRsp::set_allocated_resume_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resume_data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.resume_data_.IsDefault()) {
          _impl_.resume_data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:prpc.GetSessionParamsRsp.resume_data)
}

// -------------------------------------------------------------------

// GetBtStatusReq

// .prpc.InfoHash info_hash = 1;
inline bool GetBtStatusReq::has_info_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_hash_ != nullptr);
  return value;
}
inline void GetBtStatusReq::clear_info_hash() {
  if (_impl_.info_hash_ != nullptr) _impl_.info_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::prpc::InfoHash& GetBtStatusReq::_internal_info_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::prpc::InfoHash* p = _impl_.info_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::prpc::InfoHash&>(::prpc::_InfoHash_default_instance_);
}
inline const ::prpc::InfoHash& GetBtStatusReq::info_hash() const {
  // @@protoc_insertion_point(field_get:prpc.GetBtStatusReq.info_hash)
  return _internal_info_hash();
}
inline void GetBtStatusReq::unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_hash_);
  }
  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prpc.GetBtStatusReq.info_hash)
}
inline ::prpc::InfoHash* GetBtStatusReq::release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* released = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::prpc::InfoHash* GetBtStatusReq::unsafe_arena_release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.GetBtStatusReq.info_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* temp = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
  return temp;
}
inline ::prpc::InfoHash* GetBtStatusReq::_internal_mutable_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::prpc::InfoHash>(GetArenaForAllocation());
    _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(p);
  }
  return _impl_.info_hash_;
}
inline ::prpc::InfoHash* GetBtStatusReq::mutable_info_hash() {
  ::prpc::InfoHash* _msg = _internal_mutable_info_hash();
  // @@protoc_insertion_point(field_mutable:prpc.GetBtStatusReq.info_hash)
  return _msg;
}
inline void GetBtStatusReq::set_allocated_info_hash(::prpc::InfoHash* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::prpc::InfoHash*>(_impl_.info_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::prpc::InfoHash*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  // @@protoc_insertion_point(field_set_allocated:prpc.GetBtStatusReq.info_hash)
}

// -------------------------------------------------------------------

// GetBtStatusRsp

// .prpc.TorrentStatus status = 1;
inline bool GetBtStatusRsp::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline void GetBtStatusRsp::clear_status() {
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::prpc::TorrentStatus& GetBtStatusRsp::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::prpc::TorrentStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::prpc::TorrentStatus&>(::prpc::_TorrentStatus_default_instance_);
}
inline const ::prpc::TorrentStatus& GetBtStatusRsp::status() const {
  // @@protoc_insertion_point(field_get:prpc.GetBtStatusRsp.status)
  return _internal_status();
}
inline void GetBtStatusRsp::unsafe_arena_set_allocated_status(::prpc::TorrentStatus* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = reinterpret_cast<::prpc::TorrentStatus*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prpc.GetBtStatusRsp.status)
}
inline ::prpc::TorrentStatus* GetBtStatusRsp::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::TorrentStatus* released = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::prpc::TorrentStatus* GetBtStatusRsp::unsafe_arena_release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.GetBtStatusRsp.status)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::TorrentStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::prpc::TorrentStatus* GetBtStatusRsp::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::prpc::TorrentStatus>(GetArenaForAllocation());
    _impl_.status_ = reinterpret_cast<::prpc::TorrentStatus*>(p);
  }
  return _impl_.status_;
}
inline ::prpc::TorrentStatus* GetBtStatusRsp::mutable_status() {
  ::prpc::TorrentStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:prpc.GetBtStatusRsp.status)
  return _msg;
}
inline void GetBtStatusRsp::set_allocated_status(::prpc::TorrentStatus* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::prpc::TorrentStatus*>(_impl_.status_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::prpc::TorrentStatus*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.status_ = reinterpret_cast<::prpc::TorrentStatus*>(value);
  // @@protoc_insertion_point(field_set_allocated:prpc.GetBtStatusRsp.status)
}

// -------------------------------------------------------------------

// BtStatusRequest

// repeated .prpc.InfoHash info_hash = 1;
inline int BtStatusRequest::_internal_info_hash_size() const {
  return _internal_info_hash().size();
}
inline int BtStatusRequest::info_hash_size() const {
  return _internal_info_hash_size();
}
inline void BtStatusRequest::clear_info_hash() {
  _internal_mutable_info_hash()->Clear();
}
inline ::prpc::InfoHash* BtStatusRequest::mutable_info_hash(int index) {
  // @@protoc_insertion_point(field_mutable:prpc.BtStatusRequest.info_hash)
  return _internal_mutable_info_hash()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::prpc::InfoHash >*
BtStatusRequest::mutable_info_hash() {
  // @@protoc_insertion_point(field_mutable_list:prpc.BtStatusRequest.info_hash)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_info_hash();
}
inline const ::prpc::InfoHash& BtStatusRequest::info_hash(int index) const {
  // @@protoc_insertion_point(field_get:prpc.BtStatusRequest.info_hash)
    return _internal_info_hash().Get(index);
}
inline ::prpc::InfoHash* BtStatusRequest::add_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::prpc::InfoHash* _add = _internal_mutable_info_hash()->Add();
  // @@protoc_insertion_point(field_add:prpc.BtStatusRequest.info_hash)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::prpc::InfoHash >&
BtStatusRequest::info_hash() const {
  // @@protoc_insertion_point(field_list:prpc.BtStatusRequest.info_hash)
  return _internal_info_hash();
}
inline const ::google::protobuf::RepeatedPtrField<::prpc::InfoHash>&
BtStatusRequest::_internal_info_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.info_hash_;
}
inline ::google::protobuf::RepeatedPtrField<::prpc::InfoHash>*
BtStatusRequest::_internal_mutable_info_hash() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.info_hash_;
}

// -------------------------------------------------------------------

// BtStatusRespone

// repeated .prpc.TorrentStatus status_array = 1;
inline int BtStatusRespone::_internal_status_array_size() const {
  return _internal_status_array().size();
}
inline int BtStatusRespone::status_array_size() const {
  return _internal_status_array_size();
}
inline void BtStatusRespone::clear_status_array() {
  _internal_mutable_status_array()->Clear();
}
inline ::prpc::TorrentStatus* BtStatusRespone::mutable_status_array(int index) {
  // @@protoc_insertion_point(field_mutable:prpc.BtStatusRespone.status_array)
  return _internal_mutable_status_array()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::prpc::TorrentStatus >*
BtStatusRespone::mutable_status_array() {
  // @@protoc_insertion_point(field_mutable_list:prpc.BtStatusRespone.status_array)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_status_array();
}
inline const ::prpc::TorrentStatus& BtStatusRespone::status_array(int index) const {
  // @@protoc_insertion_point(field_get:prpc.BtStatusRespone.status_array)
    return _internal_status_array().Get(index);
}
inline ::prpc::TorrentStatus* BtStatusRespone::add_status_array() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::prpc::TorrentStatus* _add = _internal_mutable_status_array()->Add();
  // @@protoc_insertion_point(field_add:prpc.BtStatusRespone.status_array)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::prpc::TorrentStatus >&
BtStatusRespone::status_array() const {
  // @@protoc_insertion_point(field_list:prpc.BtStatusRespone.status_array)
  return _internal_status_array();
}
inline const ::google::protobuf::RepeatedPtrField<::prpc::TorrentStatus>&
BtStatusRespone::_internal_status_array() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_array_;
}
inline ::google::protobuf::RepeatedPtrField<::prpc::TorrentStatus>*
BtStatusRespone::_internal_mutable_status_array() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.status_array_;
}

// -------------------------------------------------------------------

// TorrentInfoReq

// repeated .prpc.InfoHash info_hash = 1;
inline int TorrentInfoReq::_internal_info_hash_size() const {
  return _internal_info_hash().size();
}
inline int TorrentInfoReq::info_hash_size() const {
  return _internal_info_hash_size();
}
inline void TorrentInfoReq::clear_info_hash() {
  _internal_mutable_info_hash()->Clear();
}
inline ::prpc::InfoHash* TorrentInfoReq::mutable_info_hash(int index) {
  // @@protoc_insertion_point(field_mutable:prpc.TorrentInfoReq.info_hash)
  return _internal_mutable_info_hash()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::prpc::InfoHash >*
TorrentInfoReq::mutable_info_hash() {
  // @@protoc_insertion_point(field_mutable_list:prpc.TorrentInfoReq.info_hash)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_info_hash();
}
inline const ::prpc::InfoHash& TorrentInfoReq::info_hash(int index) const {
  // @@protoc_insertion_point(field_get:prpc.TorrentInfoReq.info_hash)
    return _internal_info_hash().Get(index);
}
inline ::prpc::InfoHash* TorrentInfoReq::add_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::prpc::InfoHash* _add = _internal_mutable_info_hash()->Add();
  // @@protoc_insertion_point(field_add:prpc.TorrentInfoReq.info_hash)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::prpc::InfoHash >&
TorrentInfoReq::info_hash() const {
  // @@protoc_insertion_point(field_list:prpc.TorrentInfoReq.info_hash)
  return _internal_info_hash();
}
inline const ::google::protobuf::RepeatedPtrField<::prpc::InfoHash>&
TorrentInfoReq::_internal_info_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.info_hash_;
}
inline ::google::protobuf::RepeatedPtrField<::prpc::InfoHash>*
TorrentInfoReq::_internal_mutable_info_hash() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.info_hash_;
}

// -------------------------------------------------------------------

// TorrentInfoRes

// .prpc.TorrentInfo ti = 1;
inline bool TorrentInfoRes::has_ti() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ti_ != nullptr);
  return value;
}
inline void TorrentInfoRes::clear_ti() {
  if (_impl_.ti_ != nullptr) _impl_.ti_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::prpc::TorrentInfo& TorrentInfoRes::_internal_ti() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::prpc::TorrentInfo* p = _impl_.ti_;
  return p != nullptr ? *p : reinterpret_cast<const ::prpc::TorrentInfo&>(::prpc::_TorrentInfo_default_instance_);
}
inline const ::prpc::TorrentInfo& TorrentInfoRes::ti() const {
  // @@protoc_insertion_point(field_get:prpc.TorrentInfoRes.ti)
  return _internal_ti();
}
inline void TorrentInfoRes::unsafe_arena_set_allocated_ti(::prpc::TorrentInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.ti_);
  }
  _impl_.ti_ = reinterpret_cast<::prpc::TorrentInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prpc.TorrentInfoRes.ti)
}
inline ::prpc::TorrentInfo* TorrentInfoRes::release_ti() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::TorrentInfo* released = _impl_.ti_;
  _impl_.ti_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::prpc::TorrentInfo* TorrentInfoRes::unsafe_arena_release_ti() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.TorrentInfoRes.ti)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::TorrentInfo* temp = _impl_.ti_;
  _impl_.ti_ = nullptr;
  return temp;
}
inline ::prpc::TorrentInfo* TorrentInfoRes::_internal_mutable_ti() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.ti_ == nullptr) {
    auto* p = CreateMaybeMessage<::prpc::TorrentInfo>(GetArenaForAllocation());
    _impl_.ti_ = reinterpret_cast<::prpc::TorrentInfo*>(p);
  }
  return _impl_.ti_;
}
inline ::prpc::TorrentInfo* TorrentInfoRes::mutable_ti() {
  ::prpc::TorrentInfo* _msg = _internal_mutable_ti();
  // @@protoc_insertion_point(field_mutable:prpc.TorrentInfoRes.ti)
  return _msg;
}
inline void TorrentInfoRes::set_allocated_ti(::prpc::TorrentInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::prpc::TorrentInfo*>(_impl_.ti_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::prpc::TorrentInfo*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.ti_ = reinterpret_cast<::prpc::TorrentInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:prpc.TorrentInfoRes.ti)
}

// -------------------------------------------------------------------

// RemoveTorrentReq

// .prpc.InfoHash info_hash = 1;
inline bool RemoveTorrentReq::has_info_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_hash_ != nullptr);
  return value;
}
inline void RemoveTorrentReq::clear_info_hash() {
  if (_impl_.info_hash_ != nullptr) _impl_.info_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::prpc::InfoHash& RemoveTorrentReq::_internal_info_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::prpc::InfoHash* p = _impl_.info_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::prpc::InfoHash&>(::prpc::_InfoHash_default_instance_);
}
inline const ::prpc::InfoHash& RemoveTorrentReq::info_hash() const {
  // @@protoc_insertion_point(field_get:prpc.RemoveTorrentReq.info_hash)
  return _internal_info_hash();
}
inline void RemoveTorrentReq::unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_hash_);
  }
  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prpc.RemoveTorrentReq.info_hash)
}
inline ::prpc::InfoHash* RemoveTorrentReq::release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* released = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::prpc::InfoHash* RemoveTorrentReq::unsafe_arena_release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.RemoveTorrentReq.info_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* temp = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
  return temp;
}
inline ::prpc::InfoHash* RemoveTorrentReq::_internal_mutable_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::prpc::InfoHash>(GetArenaForAllocation());
    _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(p);
  }
  return _impl_.info_hash_;
}
inline ::prpc::InfoHash* RemoveTorrentReq::mutable_info_hash() {
  ::prpc::InfoHash* _msg = _internal_mutable_info_hash();
  // @@protoc_insertion_point(field_mutable:prpc.RemoveTorrentReq.info_hash)
  return _msg;
}
inline void RemoveTorrentReq::set_allocated_info_hash(::prpc::InfoHash* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::prpc::InfoHash*>(_impl_.info_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::prpc::InfoHash*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  // @@protoc_insertion_point(field_set_allocated:prpc.RemoveTorrentReq.info_hash)
}

// -------------------------------------------------------------------

// RemoveTorrentRes

// -------------------------------------------------------------------

// FileProgressReq

// .prpc.InfoHash info_hash = 1;
inline bool FileProgressReq::has_info_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_hash_ != nullptr);
  return value;
}
inline void FileProgressReq::clear_info_hash() {
  if (_impl_.info_hash_ != nullptr) _impl_.info_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::prpc::InfoHash& FileProgressReq::_internal_info_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::prpc::InfoHash* p = _impl_.info_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::prpc::InfoHash&>(::prpc::_InfoHash_default_instance_);
}
inline const ::prpc::InfoHash& FileProgressReq::info_hash() const {
  // @@protoc_insertion_point(field_get:prpc.FileProgressReq.info_hash)
  return _internal_info_hash();
}
inline void FileProgressReq::unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_hash_);
  }
  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prpc.FileProgressReq.info_hash)
}
inline ::prpc::InfoHash* FileProgressReq::release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* released = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::prpc::InfoHash* FileProgressReq::unsafe_arena_release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.FileProgressReq.info_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* temp = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
  return temp;
}
inline ::prpc::InfoHash* FileProgressReq::_internal_mutable_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::prpc::InfoHash>(GetArenaForAllocation());
    _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(p);
  }
  return _impl_.info_hash_;
}
inline ::prpc::InfoHash* FileProgressReq::mutable_info_hash() {
  ::prpc::InfoHash* _msg = _internal_mutable_info_hash();
  // @@protoc_insertion_point(field_mutable:prpc.FileProgressReq.info_hash)
  return _msg;
}
inline void FileProgressReq::set_allocated_info_hash(::prpc::InfoHash* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::prpc::InfoHash*>(_impl_.info_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::prpc::InfoHash*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  // @@protoc_insertion_point(field_set_allocated:prpc.FileProgressReq.info_hash)
}

// -------------------------------------------------------------------

// FileProgressRes

// .prpc.InfoHash info_hash = 1;
inline bool FileProgressRes::has_info_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_hash_ != nullptr);
  return value;
}
inline void FileProgressRes::clear_info_hash() {
  if (_impl_.info_hash_ != nullptr) _impl_.info_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::prpc::InfoHash& FileProgressRes::_internal_info_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::prpc::InfoHash* p = _impl_.info_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::prpc::InfoHash&>(::prpc::_InfoHash_default_instance_);
}
inline const ::prpc::InfoHash& FileProgressRes::info_hash() const {
  // @@protoc_insertion_point(field_get:prpc.FileProgressRes.info_hash)
  return _internal_info_hash();
}
inline void FileProgressRes::unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_hash_);
  }
  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prpc.FileProgressRes.info_hash)
}
inline ::prpc::InfoHash* FileProgressRes::release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* released = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::prpc::InfoHash* FileProgressRes::unsafe_arena_release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.FileProgressRes.info_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* temp = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
  return temp;
}
inline ::prpc::InfoHash* FileProgressRes::_internal_mutable_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::prpc::InfoHash>(GetArenaForAllocation());
    _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(p);
  }
  return _impl_.info_hash_;
}
inline ::prpc::InfoHash* FileProgressRes::mutable_info_hash() {
  ::prpc::InfoHash* _msg = _internal_mutable_info_hash();
  // @@protoc_insertion_point(field_mutable:prpc.FileProgressRes.info_hash)
  return _msg;
}
inline void FileProgressRes::set_allocated_info_hash(::prpc::InfoHash* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::prpc::InfoHash*>(_impl_.info_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::prpc::InfoHash*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  // @@protoc_insertion_point(field_set_allocated:prpc.FileProgressRes.info_hash)
}

// repeated .prpc.BtFile files = 2;
inline int FileProgressRes::_internal_files_size() const {
  return _internal_files().size();
}
inline int FileProgressRes::files_size() const {
  return _internal_files_size();
}
inline void FileProgressRes::clear_files() {
  _internal_mutable_files()->Clear();
}
inline ::prpc::BtFile* FileProgressRes::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:prpc.FileProgressRes.files)
  return _internal_mutable_files()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::prpc::BtFile >*
FileProgressRes::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:prpc.FileProgressRes.files)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_files();
}
inline const ::prpc::BtFile& FileProgressRes::files(int index) const {
  // @@protoc_insertion_point(field_get:prpc.FileProgressRes.files)
    return _internal_files().Get(index);
}
inline ::prpc::BtFile* FileProgressRes::add_files() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::prpc::BtFile* _add = _internal_mutable_files()->Add();
  // @@protoc_insertion_point(field_add:prpc.FileProgressRes.files)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::prpc::BtFile >&
FileProgressRes::files() const {
  // @@protoc_insertion_point(field_list:prpc.FileProgressRes.files)
  return _internal_files();
}
inline const ::google::protobuf::RepeatedPtrField<::prpc::BtFile>&
FileProgressRes::_internal_files() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.files_;
}
inline ::google::protobuf::RepeatedPtrField<::prpc::BtFile>*
FileProgressRes::_internal_mutable_files() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.files_;
}

// -------------------------------------------------------------------

// FileCompletedReq

// -------------------------------------------------------------------

// FileCompletedRes

// .prpc.InfoHash info_hash = 1;
inline bool FileCompletedRes::has_info_hash() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_hash_ != nullptr);
  return value;
}
inline void FileCompletedRes::clear_info_hash() {
  if (_impl_.info_hash_ != nullptr) _impl_.info_hash_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::prpc::InfoHash& FileCompletedRes::_internal_info_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::prpc::InfoHash* p = _impl_.info_hash_;
  return p != nullptr ? *p : reinterpret_cast<const ::prpc::InfoHash&>(::prpc::_InfoHash_default_instance_);
}
inline const ::prpc::InfoHash& FileCompletedRes::info_hash() const {
  // @@protoc_insertion_point(field_get:prpc.FileCompletedRes.info_hash)
  return _internal_info_hash();
}
inline void FileCompletedRes::unsafe_arena_set_allocated_info_hash(::prpc::InfoHash* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_hash_);
  }
  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:prpc.FileCompletedRes.info_hash)
}
inline ::prpc::InfoHash* FileCompletedRes::release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* released = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::prpc::InfoHash* FileCompletedRes::unsafe_arena_release_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:prpc.FileCompletedRes.info_hash)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::prpc::InfoHash* temp = _impl_.info_hash_;
  _impl_.info_hash_ = nullptr;
  return temp;
}
inline ::prpc::InfoHash* FileCompletedRes::_internal_mutable_info_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.info_hash_ == nullptr) {
    auto* p = CreateMaybeMessage<::prpc::InfoHash>(GetArenaForAllocation());
    _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(p);
  }
  return _impl_.info_hash_;
}
inline ::prpc::InfoHash* FileCompletedRes::mutable_info_hash() {
  ::prpc::InfoHash* _msg = _internal_mutable_info_hash();
  // @@protoc_insertion_point(field_mutable:prpc.FileCompletedRes.info_hash)
  return _msg;
}
inline void FileCompletedRes::set_allocated_info_hash(::prpc::InfoHash* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::prpc::InfoHash*>(_impl_.info_hash_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::prpc::InfoHash*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.info_hash_ = reinterpret_cast<::prpc::InfoHash*>(value);
  // @@protoc_insertion_point(field_set_allocated:prpc.FileCompletedRes.info_hash)
}

// int32 file_index = 2;
inline void FileCompletedRes::clear_file_index() {
  _impl_.file_index_ = 0;
}
inline ::int32_t FileCompletedRes::file_index() const {
  // @@protoc_insertion_point(field_get:prpc.FileCompletedRes.file_index)
  return _internal_file_index();
}
inline void FileCompletedRes::set_file_index(::int32_t value) {
  _internal_set_file_index(value);
  // @@protoc_insertion_point(field_set:prpc.FileCompletedRes.file_index)
}
inline ::int32_t FileCompletedRes::_internal_file_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.file_index_;
}
inline void FileCompletedRes::_internal_set_file_index(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.file_index_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace prpc


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::prpc::BtFile_State> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::prpc::BtFile_State>() {
  return ::prpc::BtFile_State_descriptor();
}
template <>
struct is_proto_enum<::prpc::DownloadRequest_ReqType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::prpc::DownloadRequest_ReqType>() {
  return ::prpc::DownloadRequest_ReqType_descriptor();
}
template <>
struct is_proto_enum<::prpc::GetMagnetUriReq_ReqType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::prpc::GetMagnetUriReq_ReqType>() {
  return ::prpc::GetMagnetUriReq_ReqType_descriptor();
}
template <>
struct is_proto_enum<::prpc::BtStateEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::prpc::BtStateEnum>() {
  return ::prpc::BtStateEnum_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_bt_2eproto_2epb_2eh
